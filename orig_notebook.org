* 3/19/19
** Initially just trying to import detailed PT cell from M1 model, ran into a few issues. Using /m1/sim/test.py

*** Error:
TypeError: a bytes-like object is required, not 'str'
Fixed:
SolnL Had to change line 83 of cfg.py1, so open('cells/popColors.pkl', 'r') -> open('cells/popColors.pkl', 'rb')

*** Error:
/home/craig/neuron/nrn/x86_64/bin/nrniv: syntax error
in PTcell.hoc near line 3444
        for (s) x_savedist(s) = distance(s)
                            ^
    xopen("PTcell.hoc")
    execute1("{xopen("PT...")
load_file("cells/PTce...")
Segmentation fault (core dumped)
- Couldn't get working for me, but Erica had same issue and managed to get it working

*** When running nrnivmodl:
Creating x86_64 directory for .o files.

Error:
/home/craig/Documents/Neurosim_Lab/m1/sim/mod
ar_traub.mod cadad.mod cadyn.mod cagk.mod cal_mh.mod cal_mig.mod canin.mod can_mig.mod catcb.mod cat_mig.mod cat_traub.mod gabab.mod h_BS.mod HCN1.mod h_harnett.mod hin.mod h_kole.mod h_migliore.mod ican_sidi.mod IC.mod IKsin.mod kap_BS.mod kapcb.mod kapin.mod kBK.mod kctin.mod kdmc_BS.mod kdr_BS.mod kdrin.mod MyExp2SynBB.mod MyExp2SynNMDABB.mod nafx.mod nap_sidi.mod nax_BS.mod savedist.mod vecstim.mod
ar_traub.mod cadad.mod cadyn.mod cagk.mod cal_mh.mod cal_mig.mod canin.mod can_mig.mod catcb.mod cat_mig.mod cat_traub.mod gabab.mod h_BS.mod HCN1.mod h_harnett.mod hin.mod h_kole.mod h_migliore.mod ican_sidi.mod IC.mod IKsin.mod kap_BS.mod kapcb.mod kapin.mod kBK.mod kctin.mod kdmc_BS.mod kdr_BS.mod kdrin.mod MyExp2SynBB.mod MyExp2SynNMDABB.mod nafx.mod nap_sidi.mod nax_BS.mod savedist.mod vecstim.mod
make:  No rule to make target 'ar_traub.mod', needed by 'ar_traub.lo'.  Stop.
- Didn't resolve, but meeting with Erica tomorrow, hopefully will get squared away.

Fixed:
Cloned the development branch of netpyne and the mechanism and hoc issues were gone. Still had to make above change to .cfg.py

*** Note:
Found chirp function in scipy

* 3/20/19
Playing around with PTcell simulation.  Trying to define arbitrary stimulation pattern.

Note:
Turning off netStim, .4 current amplitude only produces one spike.  
Replacing scalar amplitude w/ vector created by scipy.signal.chirp does not work.

* 3/21/19

Looking at how to replace IClamp step function with arbitrary waveform (scipy.signal.chirp()).
Bill and Sam suggested play(). Bill: vec.play(), Sam: play into IClamp . . .

** Issue w/ play()

x = h.Vector()
w = chirp(np.linspace(0,1,1000,endpoint=True),f0=0, f1=20, t1=1)
x.play(w)
NEURON: Optional first arg is not a POINT_PROCESS
near line 0
^
    Vector[4].play(...)
oc_restore_code tobj_count=5 should be 4
---------------------------------------------------------------------------
RuntimeError                              Traceback (most recent call last)
<ipython-input-36-5591b55ad207> in <module>()
----> 1 x.play(w)

* 3/26/19
Sam provided code (/u/samn/evoizhi/sim.py) on playing array into IClamp
* 3/27/19
** Switching over to trying single cell stuff in NEURON. 
Can load PTcell template. 
Can create PTcell: Need to pass h.PTcell the same arguments ImportCellParams in netpyne takes as "CellArgs".

Managed to apply step current and record from dendrite/soma. ~/Documents/Neurosim_Lab/netpyne/examples/PTcell/apply_chirp_first_attempt.py

** Got chirp stimulus working

* 3/30/19
** Working on getting impendance
help from interpolate():  xsrc and ysrc - what is that? don't think that's the first time seeing it

Impedance profiles looking good.

* 4/1/19
Trying 1 apical, 1 basal, make more modular - oneOfEach.py

Question: Should I be applying some noise to the denrites (both others and one being recorded)?

Different resonance / impedance profiles between dend[25] and apic[50]

aFewOfEach.py - as the name implies

* 4/9/19
** Suggestions:
*** Salva - Use Netpyne, switch over to synaptic currents, work on visualizing where dendrites are
*** Sam - Record from soma, record from all other dendrites

* 4/11/19
** Finally managed to compile mod files on XSEDE. 
Needed to add $LD_LIBRARY_PATH to export LD_LIBRARY_PATH=/opt/intel/composer_xe_2013_sp1.2.144/compiler/lib/intel64:/home/lytton/anaconda3/lib:$LD_LIBRARY_PATH 
in .bashrc

* 4/12/19
** Got transfer_example.py running on XSEDE
sbatch batcheee
Ran out of time on debug, but produced a png file, so seems good.

** Strategy for running transfer on all dendrites:
*** setup transfer_example.py to
    - accept command line arguments what section to inject w/ current-DONE
    - record from soma, and all other dendritic sections
    - only plot soma impedance stuff, save impedance curves for all dendritic sections
*** swap out call to neuron in basheee with .sh script
    - each line calls new transfer.py function

* 5/1/19
Been awhile since posting.  
Got transfer resonance and all that working and running on all cells on comet.
Just about finished with SFN abstract.

* 6/19/19
** Again, awhile since posting - finals and whatnot
** Switched over to using netstims in Netpyne
- Runs on comet
- Trying to do frequency sweep 0.5-100Hz on all dends.

* 6/20/19
Testing scripts for batching all dendrites, seems to be doing it's thing.
Wrote script for change in voltage vs frequency of netstim

* 6/21/19
Ran frequency sweep on all dends last night.
Running deltaV vs frequency script on above data.

* 6/24/19
Reorganized /home/craig/Documents/Neurosim_Lab/dendritic_resonance (local machine)

** Freq sweep analysis
- Fixed a bug in previous plotting
- added epsp amplitude plot (max voltage during stim).

** Testing simultaneous stimulation of two dendrites

** For multi-site stimulation
- Simultaneous frequency sweeps?
- All combinations of frequencies?
- All combinations of sections?

** Testing combo of all frequencies
- 2-100Hz
- increments of 1Hz

* 7/3/19
** Working on normalizing netstims
- Running Sam's suggested method (/frequency)
- Testing normalizing to AMPA and NMDA currents directly

* 7/4/19
** Plotting results from normalizing weight to frequency.  
- All seem to show peak around 25 or so.  
- Also plotted zoomed (0<freq<40).
- Running AMPA+NMDA current normalization

* 7/5/19
** Normalize to Freq.
*** Pick example from normalizing weight to frequency.
*** Rather constant, and although it's tiny, what's going on w/ change in AMPA current >30Hz? 
    - Best to ditch "delta" nmdai/ampai - current sits at zero.  
    - Going to rerun plotting

** Normalize to AMPA+NMDA
*** AMPA+NMDA current normalization still running from last night.
*** Currently treating the sum...might be better off individually.

Normalization to frequency looks pretty good (rather constant w/ the weights). 

* 7/8/19
Trying combination of two stimulations, all combos of frequencies (comboFreqSweep.py), w/ normalization.

* 7/9/19
** Combo frequency sweep timed out.  
- Giving it more time, only going 1-60 Hz (nothing really interesting past that in single stim site, so seems OK).

** Going to work on stimulating all segments of each dendritic section.
** Going to shelve multiple inputs for the time being.

Testing stimOneLoc.py on comet w/ one example (dend_59-4-batch)

** Moved analysis figures to neurosim machine

* 7/10/19

** Test job failed this morning, fixed error, running again
** Converted old notebook (m1_resonance_noteboook.txt) to this
** Looked into AMPA current weirdness.  
*** currents:
- /home/craig/Neurosim_Lab/dendritic_resonance/Netpyne_Single_Cell/currents_example.png
*** weights:
- /home/craig/Neurosim_Lab/dendritic_resonance/Netpyne_Single_Cell/netstim_weights.png

* 7/11/19
** Test for stimOneLoc finished, just about everything in order, running on all segments
** Wouldn't let me submit all segments at once, stopped on apic_34-6
** Error with loc = 0, 1
*** You can not locate a point process at position 0 or 1 if it needs an ion
/home/lytton/nrn/x86_64/bin/nrniv: ca_ion can't be inserted in this node
near line 0
nao0_na_ion = 140.0
                    ^
        MyExp2SynNMDABB(0)
>>> Traceback (most recent call last):
File "stimOneLoc.py", line 578, in <module>
    sim.createSimulateAnalyze(netParams, cfg)
File "/home/lytton/netpyne/netpyne/sim/wrappers.py", line 75, in createSimulateAnalyze
    (pops, cells, conns, stims, rxd, simData) = sim.create(netParams, simConfig, output=True)
File "/home/lytton/netpyne/netpyne/sim/wrappers.py", line 30, in create
    stims = sim.net.addStims()                    # add external stimulation to cells (IClamps etc)
File "/home/lytton/netpyne/netpyne/network/stim.py", line 103, in addStims
    self._addCellStim(params, postCell)  # call method to add connections (sort out synMechs first)
File "/home/lytton/netpyne/netpyne/network/stim.py", line 145, in _addCellStim
    postCell.addStim(params=params)
File "/home/lytton/netpyne/netpyne/cell/compartCell.py", line 968, in addStim
    self.addConn(connParams, netStimParams)
File "/home/lytton/netpyne/netpyne/cell/compartCell.py", line 670, in addConn
    synMechs, synMechSecs, synMechLocs = self._setConnSynMechs(params, secLabels)
File "/home/lytton/netpyne/netpyne/cell/compartCell.py", line 1151, in _setConnSynMechs
    synMechs = [self.addSynMech(synLabel=params['synMech'], secLabel=synMechSecs[i], loc=synMechLocs[i]) for i in range(synsPerConn)] 
File "/home/lytton/netpyne/netpyne/cell/compartCell.py", line 1151, in <listcomp>
    synMechs = [self.addSynMech(synLabel=params['synMech'], secLabel=synMechSecs[i], loc=synMechLocs[i]) for i in range(synsPerConn)] 
File "/home/lytton/netpyne/netpyne/cell/compartCell.py", line 564, in addSynMech
    synMech['hObj'] = synObj(loc, sec=sec['hObj'])  # create h Syn object (eg. h.Exp2Syn)
RuntimeError: hoc Error

*** Resolved per Bill's suggestion: numpy.linspace(1/(nseg+1),nseg/(nseg+1),nseg)

* 7/12/19
** Broke up batches between apic and basal dends
** Ran all locations on basal dends today
*** comet : /oasis/scratch/comet/ckelley/netstim_allsegs/
** submitting apic tonight
    *** ran over job limit, stopped on apic_92-3

* 7/13/19
** enough finished overnight to submit the rest

* 7/14/19
** finished running frequency sweep on all segments
** cleaning up output directory:sdsc.comet.edu: /oasis/scratch/comet/ckelly/temp_project/netstim_allsegs/
** cleanOutputDirUtil.m

* 7/15/19
** plotting freq-epsp size for each segment
** output figures : comet.sdsc.edu: /oasis/projects/nsf/shs100/ckelley/freqSweepAllSegs_Figs/

* 7/16/19
** All Segments Frequency Sweep 
*** Most basal dendrites show same peak ~25 Hz
*** Some apical denrites - apic_51, apic_52 - show somatic peak at ~15 Hz
*** Differences in amplitude of response appear disproportionately smaller at the soma than in dendrites
** TODO: Plot all segments individually - DONE
*** folder:comet.sdsc.edu: /oasis/projects/nsf/shs100/ckelley/freqSweepEachSegs_Figs/
*** TODO: Address lower limit issue for lower frequencies at soma (e.g.apic_75) - DONE
** TODO: Look into arc length distance to soma - DONE
** PAPER : Papoutsi, Kastellakis, and Poirazi - Basal tree complexity shapes functional pathways
*** Two main subtypes of Layer 5 PV cells based on basal denrite morphology
*** Also differentiable based on responses EPSP width and AP number
*** Independent of apical and somatic morph, ionic conductance dist, iNMDA/iAMPa, and synaptic load
*** Different temporal coding properties
*** Divergent behavior when arranged in microcircuits
*** Long, branchy trees - temporal integration; Short trees - coincidence detection
*** Potential for parallel processing

* 7/17/19
** All Segments Frequency Sweep
*** Turns out many apical segments have sharp somatic peaks at ~15 Hz
**** many of those have saturating behavior > 30 Hz
**** a few of those epsp > in gamma than at ~15 Hz (e.g. apic_25 - 50)
*** TODO : plots for apic_61 - 102 stil look like shit, working on that - DONE
*** Ditched the '*' for lines : comet.sdsc.edu: /oasis/scratch/comet/ckelley/freqSweepEachSegs_Figs/Change_in_Voltage_Redux/
*** Running again with smoothing : bin size = 5
**** still have edge problems w/ soma - fixed
*** Smoothed figures : comet.sdsc.edu: /oasis/scratch/comet/ckelley/freqSweepEachSegs_Figs/Change_in_Voltage_Smooth/

* 7/18//19 - Peak frequency analysis on all segments
** Moved all frequency sweep figures : comet.sdsc.edu: /oasis/projects/nsf/shs100/ckelley/freqSweepEachSegs_Figs/
** TODO : Analysis of peaks for all segments - peakFreqAnalysis.py - DONE
*** some peaks at 10 - 16 (soma), 15 - 25 (soma, dend), something like a peak ~8 (a few dend), 30 - 100 (soma)
*** running on comet
*** output file : comet.sdsc.edu: /oasis/project/nsf/shs100/ckelley/netstim_allsegs_peakFreqAnalysis.json
*** output only 1 section per category ... FIXED
*** 244  segments w/ peak in gamma, 389 w/ peak ~24 Hz, 50 w/ peak ~ 10Hz
** Using *stimOneSec.py* to work out arc length to soma
*** recursively running through parent segs
*** Code:
sim.create(netParams, cfg)

sec = 'apic_50'
loc_num = 0.5
norm3d = np.linspace(0,1,sim.net.cells[0].secs[sec]['hObj'].n3d())
ind3d = np.argmin((norm3d - loc_num)**2)
arc_loc = sim.net.cells[0].secs[sec]['hObj'].arc3d(ind3d)
total_arc = arc_loc
parent_seg = sim.net.cells[0].secs[sec]['hObj'].trueparentseg().sec.name().split('>.')[1]
while parent_seg != 'soma':
    print(parent_seg)
    sec = parent_seg
    total_arc = total_arc + sim.net.cells[0].secs[sec]['hObj'].arc3d(sim.net.cells[0].secs[sec]['hObj'].n3d()-1)
    parent_seg = sim.net.cells[0].secs[sec]['hObj'].trueparentseg().sec.name().split('>.')[1]

soma3d = np.linspace(0,1,sim.net.cells[0].secs[sec]['hObj'].n3d())
indsoma = np.argmin((soma3d - 0.5) **2)
total_arc = total_arc + (sim.net.cells[0].secs[sec]['hObj'].arc3d(sim.net.cells[0].secs[sec]['hObj'].n3d()-1) - sim.net.cells[0].secs[sec]['hObj'].arc3d(indsoma))
print(total_arc)

* 7/19/19 - Wrapping up peak frequency analysis - FIGURES
** TODO : Rerun *peakFreqAnalysis.py* with arc lenth to soma computation - DONE
*** *peakFreqAnalysis.py* update: v1.0 - starting versioning in triplicate: here, git commit message, and nb.  Needed to import sim from netpyne.
*** arc length computation assumes each child segment's 0 location is connected to its parent's 1 location
*** Output file : /oasis/projects/nsf/shs100/ckelley/netstim_allsegs_peakFreqAnalysis.json
** TODO : Analyze output from *peakFreqAnalysis.py* - DONE
*** *analyzePeakFreqOutput.py* pulls out data, saves to .mat
*** *peakFreqAnalysisFigures.m* plots everything
*** TODO : Boxplots of dendritic resonance frequency divied up by somatic resonant peak - DONE
**** All three groups, can't reject null hypothesis for Kolmogorov-Smirnov
**** two-sample t-test: low vs. medium: p = 2.5853e-18
**** medium vs. high: p = 4.9209e-192
**** low vs. high: p = 2.4443e-13
**** Figure: /u/craig/dendritic_resonance/peakFreqAnalysisFigs/dendritic_peak_frequencies.png
*** TODO : Boxplots of dendritic resonance frequency = DONE
**** Figure: /u/craig/dendritic_resonance/peakFreqAnalysisFigs/somatic_peak_frequencies.png
*** TODO : Peak frequency, amplitude vs. arc length to soma - DONE
**** For dends: amplitude somewhat interesting, frequency not so much
**** For soma: separated low and high from medium
***** both amplitudes interesting, frequency again not (didn't save plots, but included in *peakFreqAnalysisFigures.m*)
**** Figure: /u/craig/dendritic_resonance/peakFreqAnalysisFigs/dendritic_resonance_peak_amplitude_vs_distance_to_soma.png
**** Figure: /u/craig/dendritic_resonance/peakFreqAnalysisFigs/dendritic_resonance_peak_frequency_vs_distance_to_soma.png
*** TODO : Ratio of low peak amplitude to high peak amplitude vs arc length to soma - DONE
**** Figure: /u/craig/dendritic_resonance/peakFreqAnalysisFigs/ratio_low_to_high_resonant_peak_amplitudes.png

* 7/22/19 - Work on multiple  inputs
** TODO: Rerun comboFreqSweep.py, looking at combinations based on somatic peak frequency.
*** Low-Low, Low-Mid, Low-High, Mid-Mid, Mid-High, High-High
**** 4 of each combination, 24 runs total
*** Differences to *stimOneLoc.py* stimulation paradigm
**** stimOneLoc.py:
freqs = np.linspace(0.5, 100.0, 200, endpoint=True)
for freq in freqs:
    spk_interval = 1 / freq * 1000
    spk_number = np.floor(freq * 2)
    stim = {'pop': 'PT5B', 'ynorm':[0.0, 1.0], 'sec': input_sec, 'loc': location, 'synMech': ['AMPA','NMDA'], 'synMechWeightFactor': [0.5,0.5], 'start': start, \
			'interval': spk_interval, 'noise': 0.1, 'number': spk_number, 'weight': weight / freq, 'delay': 1}
    start = start + 3000
    cfg.NetStims.append(stim) 

**** comboFreqSweep.py:
freqs = np.linspace(2.0, 90.0, 89, endpoint=True)
for freq in freqs:
    spk_interval = (1 / freq) * 1000
    spk_number = np.floor(freq*2)
    spk_interval2 = (1 / freq2) * 1000
    spk_number2 = np.floor(freq2*2)
    stim = {'pop': 'PT5B', 'ynorm':[0.0, 1.0], 'sec': input_sec, 'loc': location, 'synMech': ['AMPA','NMDA'], 'synMechWeightFactor': [0.5,0.5], 'start': start, \
            'interval': spk_interval, 'noise': 0.1, 'number': spk_number, 'weight': weight / freq2, 'delay': 1}
    stim2 = {'pop': 'PT5B', 'ynorm':[0.0, 1.0], 'sec': input_sec_2, 'loc': location2, 'synMech': ['AMPA','NMDA'], 'synMechWeightFactor': [0.5,0.5], 'start': start, \
            'interval': spk_interval2, 'noise': 0.1, 'number': spk_number2, 'weight': weight / freq2, 'delay': 1}
    start = start + 3000
    cfg.NetStims.append(stim)
    cfg.NetStims.append(stim2)
*** comboFreqSweep.py - **v1.0 starting versioning notes, added specification of segment instead of just section 
**v1.1 shortened up the length of batch label
*** gen_simulStimTwoSecs_batch.py - **v1.0  editing to do combos Low-Low, Low-Mid, Low-High, Mid-Mid, Mid-High, High-High, 4 of each combination, 24 runs total
*** TESTING on comet with low-low_apic_81-apic_85-batch - KILLED
**** 48 hours of walltime
**** running, so so far so good
**** Not going to finish
*** NEW STRATEGY: each job is a single stimulation pair, lots of little jobs - TOO MANY FILES!!!
*** NEW STRATEGY: Sweep one seg, single freq on the other.
**** TESTING with low-low_apic_82-apic_81-2.0-batch
***** running
*** comboFreqSweep.py - **v1.2 added specification of stimulation frequency at one segment, frequency sweep on the othe
*** gen_simulStimTwoSecs_batch.py - **v1.1 adapted for frequency sweep on one seg, single stim frequency at the other


** PAPER: Branco & Hausser - The single dendritic branch as a fundamental functional unit in the nervous system
*** "Passive properties alone can act as a compartmentalizing force that acts in concert with the
morphology to create electrical compartments on the level of dendritic branches, thanks to the strong attenuation of
voltage across dendritic branchpoints."
*** "active properties of the dendrite can tune local signals
within a branch, either to amplify them or to dampen them, with such non-linear processing again being kept local by
the unfavourable impedance matches at branchpoints."
*** Feature detection in hippocampus
**** REFERENCE : Ujfalussy B, Kiss T, Erdi P: Parallel computational subunits in dentate granule cells generate multiple place fields
*** order of input arrival
**** REFERENCE : Torben-Nielsen B, Stiefel KM: Systematic mapping between dendritic function and structure
**** REFERENCE : Branco T, Clark BA, Hausser M: Dendritic discrimination of temporal input sequences in cortical neuron
*** "A beautiful example illustrating the importance of dendritic spikes in a neural circuit is
provided by the retina, where in directionally selective retinal ganglion cells somatic spikes are primarily trig-
gered by locally generated dendritic sodium spikes, which amplify the direction selectivity of the input"
*** Dendritic spiking influences somatic bursting
*** "Murayama et al. [13,14] provided evidence consistent with the idea that sensory stimulation
of the hindlimb is represented by dendritic calcium spikes in layer 5 pyramidal cells."
*** the optic tectum in the Xenopus tadpoles, mouse visual cortex: They demonstrate for the first time that different regions within a
dendritic tree are tuned to different stimulus features
**** REFERENCE : Jia H, Rochefort NL, Chen X, Konnerth A: Dendritic organization of sensory input to cortical neurons in vivo
*** "NMDA-dependent regenerative potentials have also been recently described in distal tuft
dendrites, where dual dendritic recordings have shown that such events can be used to signal to the soma the
localized activation of feedback inputs from the thalamus and other cortical regions [12], placing local dendritic
mechanisms in a network context."
*** Retrograde signalling through dendritic release of neurotransmitters/modulators 
**** local, input-specific negative feedback
*** Hebbian plasticity demonstrable at the single branch level
**** "given the apparent synapse-specificity of some plasticity processes and the preferential localiz-
ation of ribosomes at the base of dendritic spines, a popular hypothesis holds that this arrangement allows
for synapse-specific delivery of synaptic proteins"

** Resonance Example Figures 
*** FIGURE: Change_in_Voltage_Smooth/apic_24_at_0.5_changeInVoltage.png
*** FIGURE: Change_in_Voltage_Smooth/apic_27_at_0.25_changeInVoltage.png
*** FIGURE: Change_in_Voltage_Smooth/apic_22_at_0.25_changeInVoltage.png
*** FIGURE: Change_in_Voltage_Smooth/dend_12_at_0.25_changeInVoltage.png

* 7/23/19 - Plotting taul and *linf, reading up on HH 
** Plotting taul and linf *linfTaul.m* 
*** **v0.0 essentially porting and plotting h_migliore.mod

** Hodgkin-Huxley review
*** Erica: [[http://ecee.colorado.edu/~ecen4831/HHsumWWW/HHsum.html][HH Review]]
*** Bill's book
**** Particles - Used to describe dynamics of voltage-gated channels, don't actually exist in most cases but used for convenience
***** m (turns Na on), h (turns Na off), n (turns K on)
***** steady states - function of voltage.  minf, ninf, hinf
***** tau also parameteried by voltage
***** take on binary values for single-channel, analog 1-0 for population
***** state variables: v, m, h, n
*** Sid: http://www.opensourcebrain.org/projects/hodgkin-huxley-tutorial

** Nestim all segments discussion
*** Amplitude too low
*** DONE: Try simply increasing the weights
**** Changed initial weights from 0.5 to 1.0, submitting basal dendrites on comet
**** stimOneLoc.py - **v1.0 - starting versioning, changed initial weights from 0.5 to 1, changed output folder to netstim_allsegs_upWeight/
**** fixed up batch_apic.sh so won't go over job limit
*** Possibly inject current for higher voltage based on linf, taul, etc, add netstim ontop of that

* 7/24/19 - Running netstims w/ higher weights
** Submitted basal segments last night, finished w/ no errors, submitted most apical this morning
*** Plotting results from basal segments to check out amplitude
**** *plotFreqSweepEachSeg.py* - **v1.0 - starting versioning, changed output folder for increased weights
**** *plotFreqSweepEachSeg.py* - **v1.1 - forgot to change base_path
**** *plotFreqSweepEachSeg.py* - **v1.2 - change plotting limits for cis dend
**** *cleanOutputDirUtil.m* - **v1.0 - starting versioning, changed to only do basal dends)
*** Still not huge amplitude, but peaks are more varied, often more prominent
*** Basal example FIGURES:
**** FIGURE : Change_in_Voltage_Smooth_upWeight/dend_19_at_0.875_changeInVoltage.png
**** FIGURE : Change_in_Voltage_Smooth_upWeight/dend_20_at_0.5_changeInVoltage.png
**** FIGURE : Change_in_Voltage_Smooth_upWeight/dend_25_at_0.75_changeInVoltage.png
**** FIGURE : Change_in_Voltage_Smooth_upWeight/dend_56_at_0.875_changeInVoltage.png
*** Enough apical segments finished running to submit up to *apic_101-4*
*** Enough finished to submit the remaining apical segments 


** BME Seminar potential speakers 
*** Aurel Lazar - columbia, fruit fly guy - bill's asking
*** Matt Campisi - nyu, embedded - I'm asking
*** James Kozloski - ibm, modeling - TOO SOON, but has PAPER Dendritic spines modify action potential back-propagation in a multicompartment neuronal model
*** Hal Blumenfeld *?* - yale, epilepsy/consciousness
*** Gerwin Schalk *?* - albany, bmi

** taul, linf from *h_migliore.mod*
*** min voltage for dTaul/dV: -58.3318
*** playing with *stimOneSec.py* to use IClamp to set baseline to ~ -58.33 mV
**** Got it looping through stim amplitudes voltage >= -58.33 mV
***** running locally
***** doesn't feel like the fastest way to do it but simple
*** UPDATE: *stimOneSec.py* - **v1.0 - starting version notes, adapted to find approriate IClamp amplitude to bring dendrite to <= 58.33 mV then runs netstim ontop of that
**** Too many jobs running right now to submit a couple test sims
**** Testing on a couple (dend_30, apic_60), queued up on comet

* 7/25/19 - wrap up higher weights, check out results from IClamp to 58V
** Last apical segments finishing on comet
*** Done, cleaning up directory
*** Plotting for each segment
*** UPDATE: *plotFreqSweepEachSeg.py* - **v1.3 - edited for just the last few sections
*** UPDATE: *cleanOutputDirUtil.m* - **v1.1 - swtiched to do only apical
*** FIGURE : Change_in_Voltage_Smooth_upWeight/apic_36_at_0.75_changeInVoltage.png
*** FIGURE : Change_in_Voltage_Smooth_upWeight/apic_44_at_0.6_changeInVoltage.png
*** FIGURE : Change_in_Voltage_Smooth_upWeight/apic_81_at_0.375_changeInVoltage.png
*** FIGURE : Change_in_Voltage_Smooth_upWeight/apic_102_at_0.75_changeInVoltage.png
** Test runs for IClamp + netstim running on comet
*** Forgot to accept segment/section, but still want to see how long it takes to run 
*** dend_0 9:28:11, saved output in the wrong place
*** ran the wrong functions, fixing some bugs in *stimOneSec.py*, going to resubmit tonight

* 7/26/19 - IClamp + netstims debugging
** test scripts failed last night
*** ERROR MESSAGE:
>>> Traceback (most recent call last):
  File "stimOneSec.py", line 648, in <module>
    sim.createSimulateAnalyze(netParams,cfg)
  File "/home/lytton/netpyne/netpyne/sim/wrappers.py", line 75, in createSimulateAnalyze
    (pops, cells, conns, stims, rxd, simData) = sim.create(netParams, simConfig, output=True)
  File "/home/lytton/netpyne/netpyne/sim/wrappers.py", line 30, in create
    stims = sim.net.addStims()                    # add external stimulation to cells (IClamps etc)
  File "/home/lytton/netpyne/netpyne/network/stim.py", line 66, in addStims
    self.rand.Random123(sim.hashStr('stim_'+source['type']),
TypeError: 'NoneType' object is not subscriptable
*** UPDATE: *stimOneSec.py* - **v1.2 - uncommented cfg.analysis['plotTraces']['include'].append((pop,0)) in if cfg.addIClamp
*** resubmitted, seems to be fixed
*** New file : *iclampPlusNetstimFreqSweep.py* - **v0.0 - Use IClamp to bring voltge at dendrite to V that minimizes dTaul/dV, run frequency sweep of netstims
**** Will use for stimulating all segments
**** updated batch files for this

* 7/27/19 - more debugging
** Test scripts failed
*** UPDATE: *stimOneSec.py* - **v1.3 - forgot to change sim duration for frequency sweep

* 7/28/19 - Testing iclampPlusNetstimFreqSweep.py
** script *stimOneSec.py* finished running on comet, now testing *iclampPlusNetstimFreqSweep.py*
*** apic_28-2
** test script worked, submitting basal segments

* 7/29/19 - Running iclampPlusNetstimFreqSweep.py on all segs, combo input issues
** All segs iclamp+netstims
*** basal segments finished overnight, submitting apical segments (up to apic_92-3)
*** forgot to put in location, everything from yesterday done with loc=0.5, resubmitting basal segments
**** UPDATE: *iclampPlusNetstimFreqSweep.py* - **v0.1 - fixed bug, was previously doing everything at loc=0.5
*** enough basal segments finished to submit *batch_apic_trim.sh* and apic_0 through *apic_46-5*

** Debugging comboFreqSweep.py issues
*** ERROR: >>> Traceback (most recent call last):
  File "comboFreqSweep.py", line 8, in <module>
    location2 = float(sys.argv[8])
ValueError: could not convert string to float: 'apic_84'
*** FUNCTION CALL: ibrun /home/lytton/nrn/x86_64/bin/nrniv -python -nogui -mpi comboFreqSweep.py apic_81 0.25 0.5 apic_\
84 0.625 2.0
*** guessing it doens't treat 0.25 and 0.5 as separate arguements
*** UPDATE : *comboFreqSweep.py* - **v1.3 fixed issue with command line arguments

** PAPER : Gasparini & Magee -State-Dependent Dendritic Computation in Hippocampal CA1 Pyramidal Neurons
*** asynchronous or highly distributed inputs - linear combination of inputs
*** synchronous or spatially clustered - nonlinear response, spikes precise and invariant
*** during nontheta, spiking in CA1 precisely timed to sharp wave ripple troughs (1ms)
*** "linear and nonlinear dendritic integration can be two fundamentally distinct integra-
tion forms, with each selectively engaged by input with different temporal structure."

* [2019-7-30 Tue] - Finishing netstim + iclamp on all segs, more combo inputs
** netstim + iclamp on all segs
*** A number of jobs timed out
** combo frequency sweeps
*** upping the weights
**** UPDATE : *comboFreqSweep.py* - **v1.4 upped the weights for netstims
*** submitted test script *low-low_apic_81-apic_84-2.0-batch* - cancelled, still was in the queue at 9pm
*** submitted all batch scripts for two basal dendrites in shared partition - started immediately

* [2019-7-31 Wed] - netstim + iclamp, more just netstim, combo inputs
** netstim + iclamp
*** most of the last jobs are running, but will need to rerun anyway due to timed out jobs
*** another issue: noise = 0.1 in netstims
*** finished, now plotting
**** UPDATE: *plotFreqSweepEachSeg.py* - v1.4 - now for netstim+iclamp*
**** UPDATE: *plotFreqSweepEachSeg.py* - v1.5 - got rid of references to current, change output folder
**** output folder : comet.sdsc.edu:/oasis/scratch/comet/ckelley/temp_project/netstim_iclamp_figs/

** combo inputs
*** all jobs for two basal dendrites finished
*** Output folder: comet:/oasis/scratch/comet/ckelley/temp_project/simulFreqSweeps/
*** SCRIPT : *comboInputsAnalysis.py* - v0.0 - plotting epsp amplitudes for 1 combo inputs example
*** Figures Folder : ./comboExampFigs
**** FIGURE: ./ComboExampFigs/dend_26_at_0.125_+_dend_25_at_0.666_at_34.0.png - very linear at this weight
*** In *comboFreqSweep.py* stims are:
freqs = np.linspace(2.0, 90.0, 89, endpoint=True)
at loc1, held at one value at loc2 

** more just netstim
*** DONE : match weights and range/steps to combo inputs for 1:1 comparison
**** perhaps better, pick one segment, sweep through weights
**** SCRIPT: *stimOneLocAtWeight.py* - v0.0 - stimOneLoc.py with trimmed frequency sweep and command line arguments for weight scaling
*** Noticed in *stimOneLoc.py* - noise = 0.1 in netstims
*** Running for *dend_26* at 0.125 on comet
**** finished running in ~2hrs
**** output folder: /oasis/scratch/comet/ckelley/temp_project/netstim_weightSweep/
**** plotting SCRIPT: *plottingWeightSweep.py* - v0.0 - plot netstim weight sweep
**** UPDATE: *plottingWeightSweep.py* - v0.1 - added labels
**** issue with plotting multiple figs in loop...

** DONE: cleanup /oasis/scratch/comet/ckelley/temp_project/

* [2019-8-1 Thu] - more of the same
** netstim weight sweep
*** plotting each weight individually
**** UPDATE : *plottingWeightSweep.py* - v0.2 - changed to plot each individually
**** output folder: /oasis/scratch/comet/ckelley/temp_project/netstim_WeightSweep_figs/
**** FIGURE: [[netstim_weightSweep_figs/netstim_weightSweep_fig.png][All weights on one axis]]
**** FIGURE: [[netstim_weightSweep_figs/dend_26_at_0.125_at_1.3.png][random example weight]]
**** all weights look almost exactly the same, except height; all "jumpy  
*** running again with original noise level (0.1)
**** UPDATE: *stimOneLocAtWeight.py* - v0.1 - added noise = 0.1
**** resubmitting on comet
*** noise v. no noise
**** FIGURE: [[netstim_weightSweep_figs/dend_26_0.125_at_0.7.png][No noise, mean voltage change during stim]]
**** FIGURE: [[netstim_weightSweep_figs/dend_26_0.125_at_0.7.png][No noise, amplitude of voltage change]]
**** FIGURE: [[netstim_weightSweep_figs/dend_26_0.125_at_0.7.png][Noise, mean voltage change during stim]]
**** FIGURE: [[netstim_weightSweep_figs/dend_26_0.125_at_0.7.png][Noise, amplitude of voltage change]]
**** mean voltage rather different w/ and w/out noise
**** max voltage - base voltage almost exactly the same w/ and w/out noise except shifted up

** combo inputs - why all linear?
*** not an answer to above question, but also includes noise
*** checked *comboFreqSweep.py* and *comboInputsAnalysis.py* and everything looks OK
*** DONE: rerun w/out noise
**** UPDATE: *comboFreqSweep.py* - V1.5 - got rid of noise from netstims
**** UPDATE: *comboInputsAnalysis.py* - v0.1 - no noise
**** rerunning sans noise on comet
*** UPDATE: *comboInputsAnalysis.py* - v0.2 - added max - base in addition to mean - base
*** noise v. no noise
**** FIGURE: [[comboExampFigs/dend_26_at_0.125_+_dend_25_at_0.666_at_15.0.png][w/ noise, linearly increasing]]
**** FIGURE: [[comboExampFigs_noNoise/dend_26_at_0.125_+_dend_25_at_0.666_at_15.0.png][w/out noise, exponential decay]]
**** don't feel incredibly confident in these - either wrong or interesting
**** reran plotting on w/ noise data, came out the same
**** IGNORE: FIGURE: [[comboExampFigs_redux/dend_26_at_0.125_+_dend_25_at_0.666_at_4.0.png][w/ noise, linear change in voltage vs freq, dend_26 sweep, dend_25 held at 4Hz]]
**** FIGURE: [[comboExampFigs_noNoise/dend_26_at_0.125_+_dend_25_at_0.666_at_4.0.png][w/out noise, exp decaying change in voltage vs freq, dend_26 sweep, dend_25 held at 4Hz]]
**** FIGURE: [[comboExampFigs_redux/dend_26_at_0.125_+_dend_25_at_0.666_at_20.0.png][w/ noise, exp decaying change in voltage vs freq, dend_26 sweep, dend_25 held at 4Hz]]
**** FIGURE: [[comboExampFigs_noNoise/dend_26_at_0.125_+_dend_25_at_0.666_at_20.0.png][w/out noise, exp decaying change in voltage vs freq, dend_26 sweep, dend_25 held at 4Hz]]

* [2019-8-2 Fri] - noise
** Believe the linear behavior w/ combo inputs came from weight of stim 1 by freq of stim 2
*** [2019-7-30 Tue] *comboFreqSweep.py* - 'interval': spk_interval, 'noise': 0.1, 'number': spk_number, 'weight': weight / freq2, 'delay': 1} -> 'interval': spk_interval, 'noise': 0.1, 'number': spk_number, 'weight': weight / freq, 'delay': 1}

** Noise v. No Noise
*** running sweep of noise levels w/ initial weight=6 on comet
**** SCRIPT: *stimOneLocAtNoise.py* - v0.0 - stimOneLoc.py for noise sweep
**** SCRIPT: *plottingNoiseSweep.py* - v0.0 - plot netstim noise sweep
**** came out w/ mean change in voltage ~.6, trying upping the weight
**** UPDATE: *stimOneLocAtNoise.py* - v0.1 - trying weight = 10
**** finished running at weight = 10

* [2019-8-3 Sat] - more noise
** UPDATE: *plottingNoiseSweep.py* -  v0.1 - added AOC
** UPDATE: *stimOneLocAtNoise.py* - v0.2 - higher frequnecy resolution
** aoc and mean change in voltage (as expected) practically identical

* [2019-8-5 Mon] - M1 to CA1
** plotting higher res noise sweep from weekend
** beating dead horse, moving over to CA1
** cloned Bill's CA1 from /u/billl/nrniv/CA1hippo/ to local machine
** compiled mod files on local machine
** trimmed down *netParams.py* to just load single pyramidal cell
*** FILE: *netParamsPYR.py*
** created git repository: [[https://github.com/kelley92/CA1hippo.git][clone of Bill's CA1 model]]
*** cloned on comet
** QUESTION: which synaptic mechanisms to use?

* [2019-8-6 Tue] - Getting into CA1 pyramidal cell
** added single netstim to *netParamsPYR.py*, runs locally
*** looking for weights that don't result in spiking
*** just using AMPA
*** weight = 0.005 not bad 
**** ~2mV at 2Hz; 0.2mV at 50 Hz
** Sam's paper
*** just AMPA for synaptic resonance
*** doesn't belive peaks were particularly large
** testing frequency sweep on comet with *netParamsPYR.py*
*** 'sec': 'radTprox', 'loc': 0.5
*** freqs = np.linspace(2.0, 90.0, 89, endpoint=True)
*** output dir: /oasis/scratch/comet/ckelley/temp_project/
*** first try failed, forgot to compile mod files
*** finsihed running on comet in ~7 min 
*** also ran w/out noise

* [2019-8-7 Wed] - nestim frequency sweeps CA1
** nestim frequency sweeps CA1 pyramidal cell
*** running on different section - oridist1
**** noise v no noise (noise=0.2)
*** also ran at higher resolution
**** freqs = np.linspace(2.0, 90.0, 177, endpoint=True)
*** also added NMDA to netstim

** FIGURES:
*** [[../CA1hippo/test_netstim_ca1pyr.png][type: trace, sec: radTprox, res: low, mech: ampa, noise: 0.0]]
*** [[../CA1hippo/radtprox_lowres_nonoise_ampa.png][type: avg change in voltage during stim, sec: radTprox, res: low, mech: ampa, noise: 0.0]]
*** [[../CA1hippo/test_netstim_ca1pyr_noise.png][type: trace, sec: radTprox, res: low, mech: ampa, noise: 0.2]]
*** [[../CA1hippo/radtprox_lowres_noise_ampa.png][type: avg change in voltage during stim, sec: radTprox, res: low, mech: ampa, noise: 0.2]]
*** [[../CA1hippo/test_netstim_ca1pyr_oridist1.png][type: trace, sec: oridist1, res: low, mech: ampa, noise: 0.0]]
*** [[../CA1hippo/oridist1_lowres_nonoise_ampa.png][type: avg change in voltage during stim, sec: oridist1, res: low, mech: ampa, noise: 0.0]]]
*** [[../CA1hippo/test_netstim_ca1pyr_oridist1_noise.png][type: trace, sec: oridist1, res: low, mech: ampa, noise: 0.2]]
*** [[../CA1hippo/oridist1_lowres_noise_ampa.png][type: avg change in voltage during stim, sec: oridist1, res: low, mech: ampa, noise: 0.0]]
*** [[../CA1hippo/test_netstim_ca1pyr_oridist1_higherRes.png][type: trace, sec: oridist1, res: high, mech: ampa, noise: 0.0]]
*** [[../CA1hippo/oridist1_highres_nonoise_ampa.png][type: avg change in voltage during stim, sec: oridist1, res: high, mech: ampa, noise: 0.0]]
*** [[../CA1hippo/test_netstim_ca1pyr_radTprox_higherRes.png][type: trace, sec: radTprox, res: high, mech: ampa, noise: 0.0]]
*** [[../CA1hippo/radTprox_highres_nonoise_ampa.png][type: avg change in voltage during stim, sec: radTprox, res: high, mech: ampa, noise: 0.0]]
*** [[../CA1hippo/test_netstim_ca1pyr_oridist1_higherRes_nmda.png][type: trace, sec: oridist1, res: high, mech: ampa+nmda, noise: 0.0]]
*** [[../CA1hippo/oridist1_highres_nonoise_ampa_nmda.png][type: avg change in voltage during stim, sec: oridist1, res: high, mech: ampa+nmda, noise: 0.0]]
*** [[../CA1hippo/test_netstim_ca1pyr_radTprox_higherRes_nmda.png][type: trace, sec: radTprox, res: high, mech: ampa+nmda, noise: 0.0]]
*** [[../CA1hippo/radTprox_highres_nonoise_ampa_nmda.png][type: avg change in voltage during stim, sec: radTprox, res: high, mech: ampa+nmda, noise: 0.0]]
*** [[../CA1hippo/test_netstim_ca1pyr_oridist1_higherRes_nmda_noise.png][type: trace, sec: oridist1, res: high, mech: ampa+nmda, noise: 0.2]]
*** [[../CA1hippo/oridist1_highres_noise_ampa_nmda.png][type: avg change in voltage during stim, sec: oridist1, res: high, mech: ampa+nmda, noise: 0.2]]
*** [[../CA1hippo/test_netstim_ca1pyr_radTprox_higherRes_nmda_noise.png][type: trace, sec: radTprox, res: high, mech: ampa+nmda, noise: 0.2]]
*** [[../CA1hippo/radTprox_highres_noise_ampa_nmda.png][type: avg change in voltage during stim, sec: radTprox, res: high, mech: ampa+nmda, noise: 0.2]]

** may be issues with interstimulus period for all higher res stuff
*** DONE: rerun those

* [2019-8-8 Thu] - synaptic resonance (or lack thereof)  and chirp
** finishing up w/ rerunning higher res runs and figures
*** adding noise for higher res runs
*** FIGURES:
**** [[../CA1hippo/test_netstim_ca1pyr_oridist1_higherRes_noise.png][type: trace, sec: oridist1, res: high, mech: ampa, noise: 0.2]]
**** [[../CA1hippo/oridist1_highres_noise_ampa.png][type: avg change in voltage during stim, sec: oridist1, res: high, mech: ampa, noise: 0.2]]
**** [[../CA1hippo/test_netstim_ca1pyr_radTprox_higherRes_noise.png][type: trace, sec: radTprox, res: high, mech: ampa, noise: 0.2]]
**** [[../CA1hippo/radTprox_highres_noise_ampa.png][type: avg change in voltage during stim, sec: radTprox, res: high, mech: ampa, noise: 0.2]]

** chirp stimulus at dendrites
*** going back through code from first PT cell sims
*** FILE: [[../CA1hippo/chirpStim.py][v0.0 - Adapted from allDends.py from PT cell sims]]
*** nothing at same weight as PT cell, trying increasing by factor of 10
*** impedance looks to be more or less decreasing linearly, but argument maybe could be made for peak ~2.3Hz
**** FIGURE: [[../CA1hippo/chirp_example.png][chirp at lm_thin1]]
*** maybe try replacing *h.mod* with *h_migliore.mod* from PT cell

* [2019-8-9 Fri] - more chirp
** Replacing *h.mod* with *h_migliore.mod*
*** Migliore has leakage, absent in *h.mod*
*** Changed imports for *h.mod* to imports for *h_migliore.mod*
**** added in params taken from Migliore 2012 modeldb (fig-5a.hoc)
**** ERROR when compiling:
.libs/h_migliore.o: In function `alpt_hd':
/home/craig/Documents/Repos/CA1hippo/x86_64/h_migliore.c:292: multiple definition of `alpt_hd'
.libs/hhh.o:/home/craig/Documents/Repos/CA1hippo/x86_64/hhh.c:246: first defined here
.libs/h_migliore.o:/home/craig/Documents/Repos/CA1hippo/x86_64/h_migliore.c:135: multiple definition of `zetat_hd'
.libs/hhh.o:/home/craig/Documents/Repos/CA1hippo/x86_64/hhh.c:124: first defined here
.libs/h_migliore.o:/home/craig/Documents/Repos/CA1hippo/x86_64/h_migliore.c:133: multiple definition of `vhalft_hd'
.libs/hhh.o:/home/craig/Documents/Repos/CA1hippo/x86_64/hhh.c:122: first defined here
.libs/h_migliore.o: In function `bett_hd':
/home/craig/Documents/Repos/CA1hippo/x86_64/h_migliore.c:309: multiple definition of `bett_hd'
.libs/hhh.o:/home/craig/Documents/Repos/CA1hippo/x86_64/hhh.c:259: first defined here
.libs/h_migliore.o:/home/craig/Documents/Repos/CA1hippo/x86_64/h_migliore.c:123: multiple definition of `gmt_hd'
.libs/hhh.o:/home/craig/Documents/Repos/CA1hippo/x86_64/hhh.c:110: first defined here
.libs/h_migliore.o:/home/craig/Documents/Repos/CA1hippo/x86_64/h_migliore.c:129: multiple definition of `q10_hd'
.libs/hhh.o:/home/craig/Documents/Repos/CA1hippo/x86_64/hhh.c:118: first defined here
.libs/h_migliore.o:/home/craig/Documents/Repos/CA1hippo/x86_64/h_migliore.c:127: multiple definition of `qtl_hd'
.libs/hhh.o:/home/craig/Documents/Repos/CA1hippo/x86_64/hhh.c:116: first defined here
.libs/h_migliore.o:/home/craig/Documents/Repos/CA1hippo/x86_64/h_migliore.c:121: multiple definition of `a0t_hd'
.libs/hhh.o:/home/craig/Documents/Repos/CA1hippo/x86_64/hhh.c:106: first defined here
collect2: error: ld returned 1 exit status
/home/craig/neuron/nrn/x86_64/bin/nrnmech_makefile:94: recipe for target 'libnrnmech.la' failed
make: *** [libnrnmech.la] Error 1
**** FIX: remove *hhh.mod*, same suffix, compiles when gone
**** combine parameters from *PTcell.hoc* and *pyramidal_cell_14Vc.hoc*
***** pyramidal_cell_14Vc.hoc - gbar_hd = gh_soma; vhalfl_hd = -73
***** PTcell.hoc - ehd_hd=-30; elk_hd=-65.61; clk_hd=0.7 // params taken from Migliore 2012 modeldb (fig-5a.hoc)
***** can try by themselves as well
*** UPDATE:  [[../CA1hippo/chirpStim.py][v0.1 - switched from old h.mod to h_migliore.mod, compare]]  
*** FILE: [[../CA1hippo/pyramidal_cell_14Vc.hoc][v0.1 - swtiched from h.mod (1998) to h_migliore.mod (2010)]]
*** FIGURES - no real resonance emerges:
**** [[../CA*1hippo/chirp_radTprox_h_vs_hMigliore.png][radTprox, combo params, chirp comparison, h.mod (1998) vs h_migliore (2010)]]
**** [[../CA1hippo/chirp_oridist1_h_vs_hMigliore.png][oridist1, combo params, chirp comparison, h.mod (1998) vs h_migliore (2010)]]
**** [[../CA1hippo/chirp_lm_thin1_h_vs_hMigliore.png][radTprox, combo params, chirp comparison, h.mod (1998) vs h_migliore (2010)]]
*** try ditching params from *PTcell.hoc* - FIGURES
**** [[../CA*1hippo/chirp_radTprox_h_vs_hMigliore_justPYRparams.png][radTprox, gbar_hd = gh_soma; vhalfl_hd = -73, chirp comparison, h.mod (1998) vs h_migliore (2010)]]
**** [[../CA1hippo/chirp_oridist1_h_vs_hMigliore_justPYRparams.png][oridist1, gbar_hd = gh_soma; vhalfl_hd = -73, chirp comparison, h.mod (1998) vs h_migliore (2010)]]
**** [[../CA1hippo/chirp_lm_thin1_h_vs_hMigliore_justPYRparams.png][radTprox, gbar_hd = gh_soma; vhalfl_hd = -73, chirp comparison, h.mod (1998) vs h_migliore (2010)]]
*** try ditching CA1 specific PYR - FIGURES
**** [[../CA*1hippo/chirp_radTprox_h_vs_hMigliore_justPTparams.png][radTprox, opposite, chirp comparison, h.mod (1998) vs h_migliore (2010)]]
**** [[../CA1hippo/chirp_oridist1_h_vs_hMigliore_justPTparams.png][oridist1, opposite, chirp comparison, h.mod (1998) vs h_migliore (2010)]]
**** [[../CA1hippo/chirp_lm_thin1_h_vs_hMigliore_justPTparams.png][radTprox, opposite, chirp comparison, h.mod (1998) vs h_migliore (2010)]]

** installed vscode-neuron extension - very nice formatting for .mod, .hoc, .inc 

* [2019-8-12 Mon] - Gasparini & Magee
** Go back through PAPER: Gasparini & Magee -State-Dependent Dendritic Computation in Hippocampal CA1 Pyramidal Neurons
*** Could try to replicate stim patterns from Figure 1
*** FILE: [[repGaspariniMagee.py][v0.0 - beginning of replicating stimulation patter from Gasparini and Magee]]
**** Rather than look at synaptic resonance at 1 segment, try looking for resonance effects at multiple synapses
**** 60 synapses picked randomly from basal tree
# all possible basal synapse locations
allsyns = []
for sec in netParams.cellParams['PT5B_full'].secLists.basal:
     if netParams.cellParams['PT5B_full'].secs[sec]['geom']['nseg'] == 1:
         allsyns.append([sec, 0.5])
     else:
         nseg = netParams.cellParams['PT5B_full'].secs[sec]['geom']['nseg']
         for count, loc in enumerate(np.linspace(1/(nseg+1),nseg/(nseg+1),nseg)):
             allsyns.append([sec, loc])
# choose locations
choices = np.random.choice(len(allsyns), 60, replace=False)
syns = [allsyns[choice] for choice in choices]

**** stims arrive randomly withing a particular temporal window (500 to 25ms)
start = 5000
windows = np.linspace(500, 0, 20, endpoint=False)
for window in windows:
    for syn in syns:
        delay = np.random.randint(0,window)
        stim = {'pop': 'PT5B', 'ynorm':[0.0, 1.0], 'sec': syn[0], 'loc': syn[1], 'synMech': ['AMPA'], 'synMechWeightFactor': [1], 'start': start+delay, \
                'interval': 10, 'noise': 0, 'number': 1, 'weight': 0.1, 'delay': 1}
        cfg.NetStims.append(stim)
    start = start + 2000

*** running batch of 10 on comet, different distributions of synapses and spike times
*** Finished 10 window size sweeps
**** FIGURE: [[window_sweep_examp.png][10 sweeps through window sizes distributed as above overlayed, looks reasonable]]
*** going to try more asynchronous vs. less synchronous - just choosing from basal dends
**** FIGURE: [[asynch_140syns_500ms_vs_synch_60syns_50ms.png][140 synaptic AMPA stims randomly spaced over 500 ms vs 60 stims spaced over 50 ms]]
**** FIGURE: [[asynch_220syns_500ms_vs_synch_110syns_50ms.png][220 synaptic AMPA stims randomly spaced over 500 ms vs 110 stims spaced over 50 ms]] 
*** also tried including basal and apical (more distributed)
**** FIGURE: [[asynch_220syns_500ms_vs_synch_110syns_50ms_alldends.png][220 synaptic AMPA stims randomly spaced over 500 ms vs 110 stims spaced over 50 ms]] 
**** FIGURE: [[asynch_220syns_500ms_vs_synch_110syns_50ms_alldends_v2.png][220 synaptic AMPA stims randomly spaced over 500 ms vs 110 stims spaced over 50 ms]]

** made M1_Res and CA1hippo repos private ... just in case

* [2019-8-13 Tue] - more Gasparini and Magee style stuff
** try more clustered vs distributed, see Fig. 2,
*** First attempt:
# cluster vs distributed
sec = 'dend_56'
cluster_locs = [0.3, 0.4, 0.5, 0.6, 0.7]
distrib_locs = [0.1, 0.3, 0.5, 0.7, 0.9]
**** didn't show much effect
*** second try:
# cluster vs distributed
sec = 'dend_56'
nseg = netParams.cellParams['PT5B_full'].secs[sec]['geom']['nseg']
cluster_locs = np.linspace(1/(nseg+1),nseg/(nseg+1),nseg)
choices = np.random.choice(len(allsyns), nseg, replace=False)
syns = [allsyns[choice] for choice in choices]
# clustered
windows = [500, 250, 50, 10]
**** FIGURE: [[clustered_v_distributed_v1.png][clustered vs distributed inputs as above, nseg / Nsynapses = 9]]
**** nothing too striking, but epsp  at 50 ms is greater for clustered inputs than dist
*** third go around:
**** sec = 'dend_16'; nseg = 15
**** all basal dends as options for distributed synapses

*** apical dendrites:
sec = 'apic_16'
nseg = 10
cluster_locs = np.linspace(0.1, 0.9, nseg)
choices = np.random.choice(len(allsyns), nseg, replace=False)
syns = [allsyns[choice] for choice in choices]
# clustered
windows = [500, 250, 50, 10]
for window in windows:
    for syn_loc in cluster_locs:
        delay = np.random.randint(0,window)
        stim = {'pop': 'PT5B', 'ynorm':[0.0, 1.0], 'sec': sec, 'loc': syn_loc, 'synMech': ['AMPA'], 'synMechWeightFactor': [1], 'start': start+delay, \
                'interval': 10, 'noise': 0, 'number': 1, 'weight': 0.1, 'delay': 1}
        cfg.NetStims.append(stim)
    start = start + 2000

# distributed
for window in windows:
    for syn in syns:
        delay = np.random.randint(0,window)
        stim = {'pop': 'PT5B', 'ynorm':[0.0, 1.0], 'sec': syn[0], 'loc': syn_loc, 'synMech': ['AMPA'], 'synMechWeightFactor': [1], 'start': start+delay, \
                'interval': 10, 'noise': 0, 'number': 1, 'weight': 0.1, 'delay': 1}
        cfg.NetStims.append(stim)
    start = start + 2000
**** FIGURE: [[clustered_v_distributed_apical_v1.png][see code above]]
**** here clustering is much better than distributed
*** second apical:
**** sec = 'apic_53'; nseg = 15; cluster_locs = np.linspace(0.4, 0.6, nseg); dist_locs = np.linspace(1/(nseg+1),nseg/(nseg+1),nseg)
**** [[clustered_v_distributed_apical_v2.png][above section and # of stims]]np.linspace(

* [2019-8-14 Wed] - papers & synaptic resonance
** PAPER: Goa, et al. EEE 
*** "Local input resistance in dendrites was attained by injecting a standard current pulse (100 pA, 100 ms) and 233 measuring local Î”Vm."
*** "Plateau potentials were induced by brief (5 ms) pulses of iontophoretically ejected glutamate applied locally on individual dendrites of cortical Layer 5 pyramidal neurons"
*** "three spikes varieties including: 
**** [1] square-shaped glutamate-mediated dendritic plateau potentials
**** [2] dendrite-originating fast sodium spikes uncoupled rom somatic APs 
**** [3] fast sodium spikes associated with firing of APs in the cell body â€“ backpropagating APs."
*** "dendritic plateau potentials change the state of pyramidal cells in a profound way, with implications for neuronal network information processing. 
**** During dendritic plateau potentials, cell bodies of pyramidal neurons are in depolarized state closer to the AP firing threshold. 
**** Furthermore, during this sustained depolarized state, the somatic membrane shows a notably faster capacitative charging in response to depolarizing currents (e.g. excitation)."
*** "delay between the onset of EPSPs and the onset of EPSP-induced APs (dT) is notably shorter during the plateau.
**** Faster EPSP-to-AP transition rates are expected to improve neuronal ability for â€œtuningâ€ into the fast rhythmic afferent synaptic and network activities"
*** Here epsps are upwards of 10mV from stimulating one segment w/ NMDA and AMPA, but in Gasparini & Magee 2006, they're seeing similar amplitudes for >100 AMPA inputs, what's up with that?
*** Model Predictions:
**** 1. Plateau initiation location can be predicted from somatic plateau amplitude
**** 2. Plateau durations are greater when triggered from more distal dendritic segments
**** 3. Proximal and distal dendritic zones have different AP-generation properties
**** 4. Proximal and distal dendritic zones for bAPs.
**** 5. Plateau-evoked bAPs will interact with the plateau in the dendrite of origin, producing more Ca 2+ influx
**** 6. Membrane time constant is shortened during a plateau.
**** 7. Synaptic responses are more effective during plateau potential.

** PAPER: Ranganathan, et al. 2018 (magee lab) - Active dendritic integration and mixed neocortical network representations during an adaptive sensing behavior
*** mixed selectivity in L5 pyramidal neurons - mouse vibrissae cortex
**** CA2+ signals concurrent with whisking and modulated by the position of the whisker
**** neurons have preferred location
**** response is multiplicatively modulated by touch
*** substantial distruption of nonlinear mixing through optogenetic suppresion of dendritic calcium spikes
**** in turn, this disrupts adaptive whisking behavior
*** "A diversity of such location-selective neurons spread through out the various columns of the vibrissae cortex could produce a basis network of neurons that encode sensed-object location
independent of the whisker frame of reference"
*** "Indeed, active dendritic signals, particularly Ca 2+ plateau potentials, provide a mechanism for behavioral experience to rapidly shape cortical representations"

** Sam's synaptic resonance code - /u/samn/evoizhi/pfig.py
*** FUNCTION: *setupsynactlist* (sec,maxf=50,w0=5e-3,scalew=False) - creates list of stims from 1-maxF Hz
*** FUNCTION: *synactrun* (sec) - takes list of stims, runs frequency sweep 
*** what are *rd*, *it*, and *iv*?
****
Craig 3:46 PM
so I've been poking around your code, but can't figure out what a few variables are supposed to be.  In synresrun() you have a line it,iv = rd['vt_interp'], rd[voltLocInterp], but I can't find rd defined anywhere
any idea what/where that is? (edited) 
samn 3:47 PM
ah, it and iv are the time and voltage vectors
you can replace them and/or adjust to use your own version of time and voltage they use fixed time-steps for those vectors
Craig 3:48 PM
OK, and for epsp amplitude, you're just measuring the maximum voltage during stim?
samn 3:48 PM
is it max or delta? i have to check. getamps gets the amplitudes. looks like takes max minus min ... so the delta

** rerunning PTcell frequency sweep w/ just ampa on comet for basal segments

* [2019-8-15 Thu] - synaptic resonance and gasparini stuff
** Forgot to update repo on comet, rerunning frequency sweep w/ just AMPA on basal dendrites 
*** UPDATE: *stimOneLoc.py* - v0.1 - switched to just AMPA stims
*** output folder: /oasis/scratch/comet/ckelley/temp_project/netstim_allsegs_justAMPA/
*** batch scripts call the wrong python script . . . gotta rerun . . . resubmitted
*** figures in /oasis/scratch/comet/ckelley/temp_project/netstim_allsegs_justAMPA_figs/
*** no more interesting than with NMDA, but somatic amplitudes are very low

** Gasparini and Magee stuff
*** apical vs basal; windows = [500, 250, 50, 10] and 1 ms; n_choices = np.linspace(10, 200, 20, endpoint=True)
**** stim pattern:
# loops through window sizes, and number of synapses
n_choices = np.linspace(10, 90, 9, endpoint=True)
windows = [500, 250, 50, 10, 1]
window_starts = []
syn_lists = []
for window in windows:
    window_starts.append(window)
    for n in n_choices:
        choices = np.random.choice(len(allsyns), int(n), replace=True)
        syns = [allsyns[choice] for choice in choices]
        syn_lists.append(syns)
        for syn in syns:
            if window > 1:
                delay = np.random.randint(0,window)
            else:
                delay = np.random.rand()
            stim = {'pop': 'PT5B', 'ynorm':[0.0, 1.0], 'sec': syn[0], 'loc': syn[1], 'synMech': ['AMPA'], 'synMechWeightFactor': [1], 'start': start+delay, \
                    'interval': 10, 'noise': 0, 'number': 1, 'weight': 0.1, 'delay': 1}
            cfg.NetStims.append(stim)
        start = start + 2000
**** one full run should be ~1.5 hrs, starting at 11:35
*** was picking from all basal/apical sections, insted just picked a couple adjacent sections
**** dend_list = netParams.cellParams['PT5B_full'].secLists.apical[45:51]; dend_list = netParams.cellParams['PT5B_full'].secLists.basal[52:56]
*** nice results with the basal dendrites, need to rerun for the apical (EPSP amplitudes too low)
*** FIGURE: [[basal_dends_inputs_v_epspAmp_windowSweep.png ][randomly timed inputs spread of basal sections from dend-52 - dend-56, sweep through window sizes]]

* [2019-8-16 Fri]
** gasp magee
*** looking for reasonable weight for apical dends
**** massive EPSPs (60mV) in apical create tiny somatic EPSPs (<<1mV)
*** running just basal, clustered vs. distributed, window sweep, Ninputs from 10:100, batch of 20 on comet
**** UPDATE: *repGaspariniMagee.py* - v0.2 - just basal, clustered vs. distributed, window sweep, Ninputs from 10:100
**** output folder: /oasis/scratch/comet/ckelley/temp_project/gaspMagee/
**** changed windows params: windows = [500, 250, 100, 50, 25, 10, 1]
**** SCRIPT: *plotEPSPampsMagee.py* - v0.0 - doesnt actually plot anymore, just wrangles data from batchs
**** failed on comet, stupid typo, rerunning
**** Plotting:
plt.figure(figsize=(16,10))
plt.subplot(121)
for window in data['clustered'].keys():
    mat = np.zeros((20,10))
    for ind, run in enumerate(data['clustered'][window].keys()):
        mat[ind] = np.array(data['clustered'][window][run])
    avg = []
    err = []
    for i in range(10):
        temp_vec = []
        for j in range(20):
            temp_vec.append(mat[j][i])
        avg.append(np.mean(temp_vec))
        err.append(np.std(temp_vec))   
    plt.errorbar(np.linspace(10,100,10,endpoint=True), avg, yerr=err, label=window+' ms') 
plt.xlabel('Number of Inputs')
plt.ylabel('Somatic EPSP Amplitude (mV)')
plt.legend()
plt.title('Clustered Inputs')
#plt.ylim((0,25))

plt.subplot(122)
for window in data['distributed'].keys():
    mat = np.zeros((20,10))
    for ind, run in enumerate(data['distributed'][window].keys()):
        mat[ind] = np.array(data['distributed'][window][run])
    avg = []
    err = []
    for i in range(10):
        temp_vec = []
        for j in range(20):
            temp_vec.append(mat[j][i])
        avg.append(np.mean(temp_vec))
        err.append(np.std(temp_vec))
    plt.errorbar(np.linspace(10,100,10,endpoint=True), avg, yerr=err, label=window+' ms')     
plt.xlabel('Number of Inputs')
plt.ylabel('Somatic EPSP Amplitude (mV)')
plt.title('Distributed Inputs')
plt.legend()
#plt.ylim((0,25))
**** FIGURE: [[clustered_v_distributed_windowNinputsSweep_basal.png][clustered vs distributed inputs, varying number of inputs, different windows - linear for distributed, in part  nonlinear for clustered]]

** trying the same thing in CA1 pyramidal cell
*** SCRIPT: *gaspMageePyr.py* - v0.0 - stimulation patter from Gasparini and Magee for CA1 pyramidal cell
**** 'weight': 0.0001 gives reasonable looking results
**** doesn't require nearly as many stims to spike as PT cell (50 or fewer)

* [2019-8-18 Sun] - gasp magee stuff, input resistance
** gasp magee PT
*** cleaned up figure, soliciting feedback on slack
*** FIGURE: [[PTcell_basalDends_epspAmpVsInputs_windowSweep.png][clustered vs distributed inputs, varying number of inputs, different windows - linear for distributed, in part  nonlinear for clustered]]
*** output data file: [[basal_batch_data.json][analyzed data output from plotEPSPampsMagee.py]]

** trying similar setup on CA1 pyramidal cell
*** UPDATE: *gaspMageePyr.py* - v0.1 - clustered vs distributed setup for batches
**** stim params: 
stim = {'pop': 'Pyramidal', 'ynorm':[0.0, 1.0], 'sec': syn[0], 'loc': syn[1], 'synMech': ['AMPA'], 'synMechWeightFactor': [1], 'start': start+delay, \
        'interval': 10, 'noise': 0, 'number': 1, 'weight': 0.00003, 'delay': 1}
**** clustered only on *oridist1*
**** running on comet
**** output folder: /oasis/scratch/comet/ckelley/temp_project/gaspMageePYR/

** CA1 pyramidal cell - ModelDB: Channel density variability among CA1 neurons (Migliore et al. 2018)
*** still using *h.mod* instead of *h_migliore.mod* (i.e. no leakage)

** CA1 pyramidal cell input resistance
*** SCRIPT: *pyrInputResistance.py* - v0.0 - measuring input resistance in CA1 pyramidal cell  dends
**** just started, no far along

* [2019-8-19 Mon] - more gasp magee, comments, CA1, EEE
** CA1 pyramidal cell runs finished, analyzing
*** SCRIPT: *plotEPSPampsMagee.py* v0.0 - puts together nice output dictionary from batches (../CA1hippo)
*** ERROR:
JSONDecodeError                           Traceback (most recent call last)
~/CA1hippo/plotEPSPampsMagee.py in <module>
     21 for filename in datafiles:
     22     with open(base_path+filename,'r') as fileObj:
---> 23         data = json.load(fileObj)
     24     #clustered
     25     start = 5000

/home/lytton/anaconda3/lib/python3.7/json/__init__.py in load(fp, cls, object_hook, parse_float, parse_int, parse_constant, object_pairs_hook, **kw)
    294         cls=cls, object_hook=object_hook,
    295         parse_float=parse_float, parse_int=parse_int,
--> 296         parse_constant=parse_constant, object_pairs_hook=object_pairs_hook, **kw)
    297 
    298 

/home/lytton/anaconda3/lib/python3.7/json/__init__.py in loads(s, encoding, cls, object_hook, parse_float, parse_int, parse_constant, object_pairs_hook, **kw)
    346             parse_int is None and parse_float is None and
    347             parse_constant is None and object_pairs_hook is None and not kw):
--> 348         return _default_decoder.decode(s)
    349     if cls is None:
    350         cls = JSONDecoder

/home/lytton/anaconda3/lib/python3.7/json/decoder.py in decode(self, s, _w)
    335 
    336         """
--> 337         obj, end = self.raw_decode(s, idx=_w(s, 0).end())
    338         end = _w(s, end).end()
    339         if end != len(s):

/home/lytton/anaconda3/lib/python3.7/json/decoder.py in raw_decode(self, s, idx)
    353             obj, end = self.scan_once(s, idx)
    354         except StopIteration as err:
--> 355             raise JSONDecodeError("Expecting value", s, err.value) from None
    356         return obj, end

JSONDecodeError: Expecting value: line 1 column 1 (char 0)

**** FIX: forgot to *import json* in *gaspMageePyr.py*
*** ERROR: 
 from neuron import h
   ...: h.load_file("./cells/pyramidal_cell_14Vb.hoc")
   ...: 
   ...: #Create a PT cell
   ...: ihMod2str = {'harnett': 1, 'kole': 2, 'migliore': 3} #which model . . . 
   ...: look this up
   ...: pt_cell = h.PyramidalCell()
   ...: 
   ...: 
NEURON: lambda_f not declared at the top level
 in pyramidal_cell_14Vb.hoc near line 152
 external lambda_f
                 ^
        xopen("pyramidal_...")
      execute1("{xopen("py...")
    load_file("./cells/py...")
Segmentation fault (core dumped)

**** FIX: from neuron import h, gui
*** finished, output file: [[../CA1hippo/CA1oriens_batch_data.json][20 batches of gaspMagee stims on CA1 pyramidal cell]]
**** issue with recordStep: 0.1 -> simConfig.recordStep = 1  
*** FIGURE: [[../CA1hippo/CA1PYR_basalDends_epspAmpVsInputs_windowSweep.png][clustered vs distributed inputs, varying number of inputs, different windows, CA1 pyramidal, just oriens for distributed]]
*** UPDATE: *gaspMageePyr.py* - v0.2 - added radTprox and radTmed to list of possible locs for distributed
**** running this on comet
*** FIGURE: [[CA1PYR_basalDends_epspAmpVsInputs_windowSweep_v2.png][Descriptor]]
** Slack convo re results:
billl:car: 11:38 AM - looks good -- can we add some resonance angle here? -- i'm assuming you are just using same size inputs in above and not scaling?
Craig 11:46 AM - thanks.  for a resonance angle, I was thinking adding periodic inputs at one location on top of the plateaus you get for inputs within >10 ms windows
And for input size, where do you mean by above?  In the paper?
billl:car: 11:47 AM - why not periodic at all locs?
in prior resonance runs you reduced the amplitude at higher freq so as to keep the total input current ~= right?
Craig 11:48 AM - synchronously or no? oh, no scaling. and that's right. each single AMPA stim is treated individually and just a weight of 0.1
using weightNorm
billl:car: -  11:49 AM right so if did scaling would see resonance if any
Craig 11:50 AM - OK, so divide by window size?
or I suppose the inverse of window size rather
billl:car: 11:51 AM - window being the total duration of input? -- guess could simply keep the number of inputs ==
at diff freq so same total input
Craig 11:51 AM - yeah, so if it's a window size of 500ms and there are 20 inputs, those 20 will be randomly distributed in time within that 500ms window
billl:car: 11:55 AM - so not putting any in same loc? -- guess point is that same loc is less efficient ... can try intermediate things i guess
Craig 11:57 AM - well, some are probably in the same location
actually, some would have to be
for the clustered inputs, there are only ~20 segments to choose from
for the distributed inputs, the odds are obviously much lower
new messages
billl:car: 11:59 AM  - fully clustered inputs should give NMDA plat so should also try all this with the EEE cells
20 segs or 20 secs?  why so few?
Craig 12:00 PM - segs. that's an estimate, but something like 4 sections, ~5 segs a piece
billl:car: 12:01 PM  - how many segs in whole cell ?   >100 i assume?   so why only 20 ??
Craig 12:01 PM - they're clusterd. and i think it's something like 700
billl:car: 12:01 PM - yup clustered on 1 seg out of the 700 so 700 choices?
Craig 12:02 PM - wait, clustered on ~20 segs out of 700 (probably more like 200 since only looking at basal dends), so 20 choices
whereas the distributed inputs are distributed across however many basal segs there are
billl:car: 12:03 PM - ok so clustered on a single basilar dend -- so we should align these sims with EEE or figure out why one set of sims different from others -- ie do we have a diff kind of pyr cell in M1 or CA1 that doesn't show same behavior?
unfortunately both the EEE cell and these other models are underconstrained but still have to constrain our stories
Craig 12:04 PM - OK, I've started looking at this same thing in the CA1 cell
it's much less detailed than the M1 cell though
and does the EEE cell live somewhere I can get at?
billl:car: 12:05 PM - + grab EEE cell -- joe can guide you to location --  hmm i have here somehwere lms  https://github.com/Neurosim-lab/EEE_network
Craig 12:07 PM - Thanks. Also, regarding the CA1 cell - I looked at MIgliore's model from 2018 on ModelDB and it doesn't use  h_migliore.mod  or include leakage
billl:car: 12:08 PM - the big cell i think is here -- EEE_network/cells/eeeS_multi.py  ; @joe -- right?
so good question from carmen or rosanna -- guess can ask mm since he answers emails pretty immediately
Craig 12:09 PM - yeah, never heard back from them. can shoot him an email
joe 12:09 PM - eeeD.py is the detailed morphology model: https://github.com/Neurosim-lab/EEE_network/blob/master/cells/eeeD.py
Craig 12:09 PM - Thanks, Joe

** DONE: email Migliore: Michele Migliore (CNR)" <michele.migliore@cnr.it

* [2019-8-20 Tue] - weighted stims, checking out EEE cell, deep learning
** PT cell
*** Should I also try w/ NMDA?
*** DONE: run sans weights w/ cluster on different basilar dend(s)
**** UPDATE: repGaspariniMagee.py - v0.3 - different basal cluster
**** basal sections 34-37
**** running on comet
**** output folder: /oasis/scratch/comet/ckelley/temp_project/gaspMagee2/
**** FIGURE: [[./PTcell_basalDends34-37_epspAmpVsInputs_windowSweep.png][clusterd vs. distributed, epsp vs N inputs, sweep over window size, basal sections 34-37]]
*** Weighted Frequnecy Sweep
**** SCRIPT: gaspMageeWeightedStims.py - v0.0 - weighted frequency sweep based on gasparini & magee stimulation patterns
**** running on comet
**** stupid error while saving, running again

* [2019-8-21 Wed] - more of the same
** PT cell
*** from yesterday [2019-8-20 Tue], weighted freq sweep pretty much 1/f at n=60, trying n=100
**** running on comet now 
*** Trying both weighted and unweighted w/ NMDA as well
**** UPDATE: repGaspariniMagee.py - v0.5 - add NMDA stims as wel
**** UPDATE: gaspMageeWeightedStims.py - v0.1 - added NMDA 
**** running both on comet
**** FIGURE: [[./PTcellWeightedStimsV2.png][weighted stims, fixed n=100, clustered and distributed, no resonance . . .]] 
*** Look at AMPA + NMDA
**** FIGURE: [[./PTcellWeightedStimsNMDA][weighted stims, fixed n=100, clustered and distributed, AMPA+NMDA, no visible resonance]]
**** FIGURE: [[./PTcell_AMPAnNMDA_basalDends34-37_epspAmpVsInputs_windowSweep.png][unweighted, clustered and distributed, epsp amp vs. inputs, window sweep, AMPA+NMDA]]
** Deep learning
*** from yesterday [2019-8-20 Tue], one possible application - Labeling periods of NMDA plateuas from spiking data 
*** rented sejnowski's suggested book . . . doesn't open w/ kindle chrome extension - recommends phone or tablet . . . don't own a tablet
*** Goodfellow, Bengio, Courville - Deep learning
**** Some math review: SVMs, kernel trick, probability & information theory, regularization
***** regularization - "any modification we make to a learning algorithm that is intended to reduce its generalization error but not its training error"
**** Deep Feedforward Networks (Chapter 6)
***** strategy is to learn basis functions/phi, phi is a hidden layer\
***** w/ stochastic gradient descent, important to initialize weights to small, random values, because convergence is not guaranteed
***** Universal Approximation Theoren (Hornik et al 1989, Cybenko et al 1989)L A feedforward network with a linear output layer and at least one hidden layer with a "squashing" activation
function can approximate any Borel measurable function from one finite dimensional space to another with any desired nonzero amount of error, provided the network has sufficiently many 
hidden units
***** greater depth empiracally leads to better generalization and can reduce necessary number of hidden units (width)
***** for feedforward networks, rectification is more important for performance than learning the right weights
** EEE Cell
*** cloned EEE_network from github 
**** just running init.py as is - ERROR:
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
~/Documents/Repos/EEE_network/eee_single/init.py in <module>()
     27 sim.net.connectCells()        # create connections between cells based on params
     28 sim.net.addStims()            # add network stimulation
---> 29 sim.setupRecording()          # setup variables to record (spikes, V traces, etc)
     30 sim.runSim()                  # run parallel Neuron simulation
     31 sim.gatherData()              # gather spiking data and cell info from each node

~/anaconda3/envs/py36/lib/python3.6/site-packages/netpyne/sim/setup.py in setupRecording()
    259         # get list of cells from argument of plotTraces function
    260         if 'plotTraces' in sim.cfg.analysis and 'include' in sim.cfg.analysis['plotTraces']:
--> 261             cellsPlot = utils.getCellsList(sim.cfg.analysis['plotTraces']['include'])
    262         else:
    263             cellsPlot = []

~/anaconda3/envs/py36/lib/python3.6/site-packages/netpyne/sim/utils.py in getCellsList(include, returnGids)
     68 
     69         elif isinstance(condition, basestring):  # entire pop
---> 70             cellGids.extend(list(sim.net.pops[condition].cellGids))
     71 
     72         elif isinstance(condition, tuple) or isinstance(condition, list):  # subset of a pop with relative indices

~/anaconda3/envs/py36/lib/python3.6/site-packages/netpyne/specs/dicts.py in __getitem__(self, k)
    182 
    183     def __getitem__(self, k):
--> 184         return super(ODict, self).__getitem__(k)
    185 
    186 

KeyError: 'eeeD'
**** getting rid of *cfg, netParams = sim.readCmdLineArgs()* for *from netParams import netParams; from cfg import cfg* - ERROR:
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
~/Documents/Repos/EEE_network/eee_single/init.py in <module>()
     15 
     16 # cfg, netParams = sim.readCmdLineArgs()
---> 17 from netParams import netParams
     18 from cfg import cfg
     19 

~/Documents/Repos/EEE_network/eee_single/netParams.py in <module>()
     47 
     48 ## Import eeeD cell
---> 49 cellRule = netParams.importCellParams(label='eeeD', conds={'pop':'eeeD'}, fileName=eeeD_path, cellName='MakeCell', cellInstance=True)
     50 netParams.cellParams['eeeD'] = cellRule
     51 

~/anaconda3/envs/py36/lib/python3.6/site-packages/netpyne/specs/netParams.py in importCellParams(self, label, conds, fileName, cellName, cellArgs, importSynMechs, somaAtOrigin, cellInstance)
    337             label = int(self._labelid)
    338             self._labelid += 1
--> 339         secs, secLists, synMechs, globs = conversion.importCell(fileName, cellName, cellArgs, cellInstance)
    340         cellRule = {'conds': conds, 'secs': secs, 'secLists': secLists, 'globals': globs}
    341 

~/anaconda3/envs/py36/lib/python3.6/site-packages/netpyne/conversion/neuronPyHoc.py in importCell(fileName, cellName, cellArgs, cellInstance)
    192         modulePointer = tempModule
    193         if isinstance(cellArgs, dict):
--> 194             cell = getattr(modulePointer, cellName)(**cellArgs) # create cell using template, passing dict with args
    195         else:
    196             cell = getattr(modulePointer, cellName)(*cellArgs)  # create cell using template, passing list with args

~/Documents/Repos/EEE_network/cells/eeeD.py in MakeCell()
   2088 ############################################
   2089 def MakeCell():
-> 2090     cell = eeeD()
   2091     return cell

~/Documents/Repos/EEE_network/cells/eeeD.py in __init__(self)
    134         self.optimize_nseg()
    135         self.add_axon()
--> 136         self.add_all()
    137         self.addsomachan()
    138         self.addapicalchan()

~/Documents/Repos/EEE_network/cells/eeeD.py in add_all(self)
    243     def add_all(self):
    244         for sec in self.all:
--> 245             sec.insert('vmax')
    246             sec.insert('pas')
    247             sec.e_pas = pasVm

ValueError: argument not a density mechanism name.
**** FIX: softlink path to mechanism folder was wrong, moved x86_64 to /mod

* [2019-8-22 Thu]
** PT Cell
*** Tried looking at mean V during stim rather than epsp amplitude, first pass didn't look promisings
** read papers on deep learning
*** was bad about taking notes

* [2019-8-23 Fri] - more clusterd/distributed inputs, machine learning
** Yesterday's [2019-8-22 Thu] reading
*** Goodfellow, Bengio, Courville - Deep learning; Chapter 7; regularization
**** review of ridge and lasso regularization, early stopping, dropout
**** adversarial training - training on small, deliberate examples that trip up network (e.g. panda + 0.007*nematode = gibbon)
*** PAPER: Anthony Zador - A Critique of Pure Learning, 2019
**** learning in animals is probably not through a "clever" learning algorithm, but due to the highly structered connectivity of the brain 
**** since wiring diagram can't be encoded in genome (except for c. elegans and such), must be compressed through a "genetic bottleneck"
**** Hinton and Lecun seriosuly favor unsupervised learning
**** so much complex animal behavior (e.g. hunting in spiders) is innate
**** learning in animals like two concentric loops: inner loop is largely unsupervised and occurs on scale of a lifetime;
outer loop is essentially supervised (by selection/fitness) and occurs on the scale of generations
**** makes argumetn for more biologically inspired (e.g. cortically inspired) architecture in ANNs
*** PAPER: Lee et at. - Training Deep Spiking Convolutional Neural Networks With STDP-Based Unsupervised Pre-training Followed by Supervised Fine-Tuning (2018)
**** convolutional layers are pretrained, unsupervised, followed by fine tuning via end to end backprop 
***** similar strategy to Sam's abstract on games
**** network built of leaky integrate and fire neurons
**** 2.5x increase in speed of training, increased robustness and generalization
** Trying to replicate original clustered vs. distributed inputs results from PT cell in EEE cell
*** SCRIPT: gaspMageeEEE.py - v0.0 - replicating original clustered vs. distributed inputs results from PT cell in EEE cell 
*** issue commit changes w/ git:
git add ./eee_single/gaspMageeEEE.py 

git commit -a
[resonance 7a1af01] gaspMageeEEE.py - v0.0 - replicating original clustered vs. distributed inputs results from PT cell in EEE cell
 2 files changed, 539 insertions(+)
 create mode 100644 eee_single/gaspMageeEEE.py

git push
fatal: The current branch resonance has no upstream branch.
To push the current branch and set the remote as upstream, use

    git push --set-upstream origin resonance

git push --set-upstream origin resonance
Username for 'https://github.com': kelley92
Password for 'https://kelley92@github.com': 
remote: Permission to Neurosim-lab/EEE_network.git denied to kelley92.
fatal: unable to access 'https://github.com/Neurosim-lab/EEE_network.git/': The requested URL returned error: 403
**** for now, just doing a fresh clone on comet, then copying over gaspMageeEEE.py
**** running on comet
**** forgot to import json, running again
** Helping james w/ notebook and epilepsy project
** Goodfellow, Bengio, Courville - Deep learning; Chapter 8; Optimization
*** 0-1 loss for classification not differentiable. Better to use negative log likelihood of the correct class

* [2019-8-25 Sun] - EEE cell w/ gasp magee stims
** FIGURE: [[./EEEcell_basalDends_epspAmpVsInputs_windowSweep.png][epsp amp vs n inputs, window sweep, clustered v. distributed, EEE cell]]

* [2019-8-26 Mon] - more w/ EEE cell
** add NMDA as before
*** UPDATE - gaspMageeEEE.py - v0.1 - added NMDA
*** running on comet; output folder: /oasis/scratch/comet/ckelley/temp_project/gaspMageeEEENMDA/
** using glutamate puffs and extrasynaptic NMDA
*** for extrasynaptic delay - appears to just be NMDA stim at the same loc as [AMPA,NMDA] at the same weight with a delay of 2 relative to previous stim
**** from *cfg.py*:
# Glutamate stim parameters
cfg.glutamate         = True
cfg.synTime           = 200.0
cfg.numSyns           = 24
cfg.numExSyns         = cfg.numSyns
cfg.glutAmp           = 2.0
cfg.glutAmpExSynScale = 1.0
cfg.glutAmpDecay      = 0.0 # percent/um
cfg.synLocMiddle      = 0.3 #0.45 
cfg.synLocRadius      = 0.15 
cfg.initDelay         = 10.0
cfg.synDelay          = 2.0 # ms/um
cfg.exSynDelay        = 4.0 # ms/um
cfg.glutPuffSyn = {'loc': list(np.linspace(cfg.synLocMiddle-cfg.synLocRadius, cfg.synLocMiddle+cfg.synLocRadius, cfg.numSyns)), 'sec': 'basal_8', 'synMech': ['NMDA','AMPA'], 'start': cfg.synTime, 'interval': 1000, 'noise': 0.0, 'number': 1, 'weight': cfg.glutAmp, 'delay': cfg.synDelay}
cfg.glutPuffExSyn = {'loc': list(np.linspace(cfg.synLocMiddle-cfg.synLocRadius, cfg.synLocMiddle+cfg.synLocRadius, cfg.numExSyns)), 'sec': 'basal_8', 'synMech': ['NMDA'], 'start': cfg.synTime, 'interval': 1000, 'noise': 0.0, 'number': 1, 'weight': cfg.glutAmp * cfg.glutAmpExSynScale, 'delay': cfg.exSynDelay}
*** FILE: gaspMageeEEEexSynNMDA.py - v0.0 - replicating original clustered vs. distributed inputs results from PT cell in EEE cell with AMPA + NMDA + exSynNMDA
*** runnign on comet; output folder: /oasis/scratch/comet/ckelley/temp_project/gaspMageeEEEexSynNMDA/
*** both just [AMPA+NMDA] and w/ extrasynaptic NMDA result in figing
** extrasynaptic NMDA w/ PT cell
*** UPDATE: repGaspariniMagee.py - v0.6 - extrasynaptic NMDA

* [2019-8-27 Tue] - spatiotemporal characteristics of EEE stims
** Gasparini Magee style figures:
*** FILE: plottingPTcellGaspMagee.py - v0.0 - generate composite figure for PT cell unweighted
*** FIGURE: [[./PTcellComposite.png][PT cell, clustered vs distributed, epsp amp vs n inputs, window size sweep; AMPA, AMPA+NMDA, AMPA+NMDA+exSynNMDA]]
** EEE Cell:
*** all stims delivered at exactly the same time, looking at temporal distribution of inputs
*** FILE: [[glutPuffTempDyn.py][v0.0 - looking at delivering glut puffs over several tine windows]]
**** clustered as in EEE sims, clustered on single dend, and distributed across basal tree 

* [2019-8-28 Wed] - continuing from yesterday - some kind of resonance
** run batch of 50 of *glutPuffTempDyn.py* on comet
*** FILE: glutPuffTempDyn.py - v0.1 - setup for running batches on comet
*** output folder: /oasis/scratch/comet/ckelley/temp_project/glutPuffBatches/)
*** seems interesting - spiking resonance at 100 ms window size (10Hz) for distributed inputs
*** FIGURE: [[../EEE_network/eee_single/EEEcell_spkCountVsWIndowSize_threeDists.png][spike counts for 24 Glutamate inputs randomly distributed within varying window sizes at different spatial distributions]]
** trying hyperpolarizing to prevent spiking
*** UPDATE: glutPuffTempDyn.py - v0.2 - hyperpolarize to prevent spiking
*** output folder /oasis/scratch/comet/ckelley/temp_project/glutPuffBatchesHyper/
*** FIGURE: [[../EEE_network/eee_single/EEEcell_hyperpolarized_epspAmptVsWIndowSize_threeDists][Same as above with hyperpolarizing IClanp to prevent spiking]]
**** regarding results: 
Bill - looks mostly consistent but still would like answer to question:  seems contrary to the EEE story which is that most clustered (spatially) would give the highest response due to NMDA plat?1

* [2019-8-29 Thu] - PT cell and EEE cell
** PT Cell
*** Realized there shouldn't be a need for weighting stims, because it's the same number of stims regardless of the window size, so current should be constant (right?)
**** UPDATE: *gaspMageeWeightedStims.py* - v0.2 - dropped NMDA and weighting
**** running on comet, output folder: /oasis/scratch/comet/ckelley/temp_project/gaspMageeUnWeighted/
**** UPDATE: *plotWeightedStims.py* - v0.0 - plotting unweighted stims now
**** forgot to ditch weighting for clustered stims - rerunning on comet
**** FIGURE: [[./PTcellUnWeightedStimsAvg.png][100 stims, various window sizes, clustered saturates faster than distributed, but no resonance]]
*** Sam's code:
**** calls *synresrun()* from notebook:
python -i sim.py 
execfile("load.py"); execfile("pfig.py")
dout = synresrun(cell,cell.apic,baset=10000.0,maxf=30,w0=2.5e-4,scalew=False)
pickle.dump(dout,open('data/17aug18_CSTR_BS1579_apic_synres.pkl','w'))
** EEE Cell
*** Realized that netstims and glutpuff aren't comparable
**** glutpuff code:
# Glutamate stim parameters
cfg.glutamate         = True

cfg.synTime           = 200.0
cfg.numSyns           = 24
cfg.numExSyns         = cfg.numSyns
cfg.glutAmp           = 2.0
cfg.glutAmpExSynScale = 1.0
cfg.glutAmpDecay      = 0.0 # percent/um
cfg.synLocMiddle      = 0.3 #0.45 
cfg.synLocRadius      = 0.15 
cfg.initDelay         = 10.0
cfg.synDelay          = 2.0 # ms/um
cfg.exSynDelay        = 4.0 # ms/um

cfg.glutPuffSyn = {'loc': list(np.linspace(cfg.synLocMiddle-cfg.synLocRadius, cfg.synLocMiddle+cfg.synLocRadius, cfg.numSyns)), 'sec': 'basal_8', 'synMech': ['NMDA','AMPA'],
                'start': cfg.synTime, 'interval': 1000, 'noise': 0.0, 'number': 1, 'weight': cfg.glutAmp, 'delay': cfg.synDelay}

cfg.glutPuffExSyn = {'loc': list(np.linspace(cfg.synLocMiddle-cfg.synLocRadius, cfg.synLocMiddle+cfg.synLocRadius, cfg.numExSyns)), 'sec': 'basal_8', 'synMech': ['NMDA'],
                'start': cfg.synTime, 'interval': 1000, 'noise': 0.0, 'number': 1, 'weight': cfg.glutAmp * cfg.glutAmpExSynScale, 'delay': cfg.exSynDelay}

if cfg.glutamate:

    for nslabel in [k for k in dir(cfg) if k.startswith('glutPuff')]:

        ns = getattr(cfg, nslabel, None)        
            
        branch_length = netParams.cellParams['eeeS']['secs'][ns['sec']]['geom']['L']

        if "ExSyn" in nslabel:
            cur_locs = np.linspace(cfg.synLocMiddle-cfg.synLocRadius, cfg.synLocMiddle+cfg.synLocRadius, cfg.numExSyns)
            cur_dists = branch_length * np.abs(cur_locs - cfg.synLocMiddle)
            cur_weights = (cfg.glutAmp * cfg.glutAmpExSynScale) * (1 - cur_dists * cfg.glutAmpDecay/100)
            cur_weights = [weight if weight > 0.0 else 0.0 for weight in cur_weights]
            cur_delays = cfg.initDelay + (cfg.exSynDelay * cur_dists)
                  
              
        elif "Syn" in nslabel:
            cur_locs = np.linspace(cfg.synLocMiddle-cfg.synLocRadius, cfg.synLocMiddle+cfg.synLocRadius, cfg.numSyns)
            cur_dists = branch_length * np.abs(cur_locs - cfg.synLocMiddle)
            cur_weights = cfg.glutAmp * (1 - cur_dists * cfg.glutAmpDecay/100)
            cur_weights = [weight if weight > 0.0 else 0.0 for weight in cur_weights]
            cur_delays = cfg.initDelay + (cfg.synDelay * cur_dists)                
              
        else:
            raise Exception("Should have had Syn or ExSyn in name. See netParams.py")             
        
        # add stim source
        netParams.stimSourceParams[nslabel] = {'type': 'NetStim', 'start': ns['start'], 'interval': ns['interval'], 'noise': ns['noise'], 'number': ns['number']}  

        # connect stim source to target
        for cur_pop in ['eeeD', 'eeeS']:    

            for i in range(len(ns['synMech'])):
                
                netParams.stimTargetParams[nslabel+'_'+cur_pop+'_'+ns['synMech'][i]] = {'source': nslabel, 'conds': {'pop': cur_pop}, 'sec': ns['sec'], 'synsPerConn': cfg.numSyns,
                                                                                    'loc': list(cur_locs), 'synMech': ns['synMech'][i], 'weight': list(cur_weights), 'delay': list(cur_delays)}

**** glutpuff example netStimTargetParams
{glutPuffExSyn_eeeD_NMDA: {'source': 'glutPuffExSyn', 'conds': {'pop': 'eeeD'}, 'sec': 'basal_8', 'synsPerConn': 24,
                            'loc': [0.15, 0.16304347826086957, 0.1760869565217391, 0.1891304347826087, 0.20217391304347826, 0.2152173913043478, 0.22826086956521738,
                                    0.24130434782608695, 0.2543478260869565, 0.26739130434782604, 0.2804347826086956, 0.2934782608695652, 0.3065217391304348, 0.3195652173913043,
                                    0.3326086956521739, 0.3456521739130434, 0.35869565217391297, 0.37173913043478257, 0.3847826086956521, 0.39782608695652166, 0.41086956521739126,
                                     0.42391304347826086, 0.43695652173913035, 0.44999999999999996], 
                            'synMech': 'NMDA', 'weight': [2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0],
                            'delay': [109.75565495009285, 101.0812501718239, 92.40684539355497, 83.73244061528602, 75.05803583701707, 66.38363105874814, 57.70922628047919, 49.03482150221024,
                                    40.36041672394131, 31.68601194567238, 23.01160716740345, 14.337202389134482, 14.337202389134482, 23.011607167403376, 31.686011945672345, 40.36041672394127,
                                    49.03482150221021, 57.70922628047917, 66.38363105874811, 75.05803583701703, 83.732440615286, 92.40684539355497, 101.08125017182385, 109.75565495009283]}

**** Question on slack: This is one of the entries in netParams.stimTargetParams for the single EEE cell.  There are 24 synsPerConn, and 24 entries in 'loc', 'weight', and 'delay'.  
Would it be equivalent to have 24 sources and 24 entries in netParams.stimTargetParams, one for each of those entries in 'loc', 'weight', and 'delay' and with  'synsPerConn' : 1?

* [2019-8-30 Fri] 
** Trying to run Sam's code
*** Local machine:
**** First try 
(py36) craig@craig-GL63-8RC:/pt/u$ ipython -i sim.py
Python 3.6.7 |Anaconda, Inc.| (default, Oct 23 2018, 19:16:44) 
Type 'copyright', 'credits' or 'license' for more information
IPython 6.5.0 -- An enhanced Interactive Python. Type '?' for help.
dlopen failed - 
x86_64/.libs/libnrnmech.so: undefined symbol: _naf2_reg
---------------------------------------------------------------------------
ModuleNotFoundError                       Traceback (most recent call last)
/pt/u/sim.py in <module>()
      6 import random
      7 import time
----> 8 import inspyred
      9 from inspyred import ec
     10 from inspyred.ec import terminators

ModuleNotFoundError: No module named 'inspyred'
**** installed inspyred, tried again
(py36) craig@craig-GL63-8RC:/pt/u$ ipython -i sim.py
Python 3.6.7 |Anaconda, Inc.| (default, Oct 23 2018, 19:16:44) 
Type 'copyright', 'credits' or 'license' for more information
IPython 6.5.0 -- An enhanced Interactive Python. Type '?' for help.
dlopen failed - 
x86_64/.libs/libnrnmech.so: undefined symbol: _naf2_reg
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
/pt/u/sim.py in <module>()
     16 import pickle
     17 import numpy
---> 18 h.install_sn() # for SpikeTrainEditDist
     19 h.install_vecst() # for samp and other NQS/vecst functions
     20 from spike import * # for spike/ISI functions

AttributeError: 'hoc.HocObject' object has no attribute 'install_sn'

*** Neurosim machine (pt):
pt% conda activate py36
pt% python -i sim.py
Warning: no DISPLAY environment variable.
--No graphics will be displayed.
dlopen failed - 
x86_64/.libs/libnrnmech.so: undefined symbol: _naf2_reg
Traceback (most recent call last):
  File "sim.py", line 8, in <module>
    import inspyred
ModuleNotFoundError: No module named 'inspyred'
>>> 
** EEE Cell 
*** playing with glutamate puffs in *cfg.py*

* [2019-9-1 Sun] - EEE glutamate puffs
** Trying to exactly replicate glut puff with 1 source - 1 target netstims
*** FILE: *repGlutPuff.py* - v0.0 - replicate glut puff with 1 source - 1 target netstims

* [2019-9-3 Tue] - more EEE glutamate puffs
** effects of radius:
*** radii = 0.05 - 0.25
*** super dependent on synLocMiddle
*** parameters:
# Glutamate stim parameters
cfg.glutamate         = True
cfg.synTime           = 200.0
cfg.numSyns           = 24
cfg.numExSyns         = cfg.numSyns
cfg.glutAmp           = 2.0
cfg.glutAmpExSynScale = 1.0
cfg.glutAmpDecay      = 0.0 # percent/um
cfg.synLocMiddle      = 0.3 #0.45
cfg.synLocRadius      = 0.15
cfg.initDelay         = 10.0
cfg.synDelay          = 2.0 # ms/um
cfg.exSynDelay        = 4.0 # ms/um
cfg.glutPuffSyn = {'loc': list(np.linspace(cfg.synLocMiddle-cfg.synLocRadius, cfg.synLocMiddle+cfg.synLocRadius, cfg.numSyns)), 'sec': 'basal_8', 'synMech': ['NMDA','AMPA'],
                    'start': cfg.synTime, 'interval': 1000, 'noise': 0.0, 'number': 1, 'weight': cfg.glutAmp, 'delay': cfg.synDelay, 'radius' : 0.05, 'nSyns' : 24}
cfg.glutPuffExSyn = {'loc': list(np.linspace(cfg.synLocMiddle-cfg.synLocRadius, cfg.synLocMiddle+cfg.synLocRadius, cfg.numExSyns)), 'sec': 'basal_8', 'synMech': ['NMDA'],
                    'start': cfg.synTime, 'interval': 1000, 'noise': 0.0, 'number': 1, 'weight': cfg.glutAmp * cfg.glutAmpExSynScale, 'delay': cfg.exSynDelay, 'radius' : 0.05, 'nSyns' : 24}
cfg.glutPuffSyn2 = {'loc': list(np.linspace(cfg.synLocMiddle-cfg.synLocRadius*2, cfg.synLocMiddle+cfg.synLocRadius*2, cfg.numSyns)), 'sec': 'basal_8', 'synMech': ['NMDA','AMPA'],
                    'start': cfg.synTime+800, 'interval': 1000, 'noise': 0.0, 'number': 1, 'weight': cfg.glutAmp, 'delay': cfg.synDelay, 'radius' : 0.1, 'nSyns' : 24}
cfg.glutPuffExSyn2 = {'loc': list(np.linspace(cfg.synLocMiddle-cfg.synLocRadius*2, cfg.synLocMiddle+cfg.synLocRadius*2, cfg.numExSyns)), 'sec': 'basal_8', 'synMech': ['NMDA'],
                    'start': cfg.synTime+800, 'interval': 1000, 'noise': 0.0, 'number': 1, 'weight': cfg.glutAmp * cfg.glutAmpExSynScale, 'delay': cfg.exSynDelay, 'radius' : 0.1, 'nSyns' : 24}
cfg.glutPuffSyn3 = {'loc': list(np.linspace(cfg.synLocMiddle-cfg.synLocRadius, cfg.synLocMiddle+cfg.synLocRadius, cfg.numSyns/2)), 'sec': 'basal_8', 'synMech': ['NMDA','AMPA'],
                    'start': cfg.synTime+1600, 'interval': 1000, 'noise': 0.0, 'number': 1, 'weight': cfg.glutAmp, 'delay': cfg.synDelay, 'radius' : 0.15, 'nSyns' : 24}
cfg.glutPuffExSyn3 = {'loc': list(np.linspace(cfg.synLocMiddle-cfg.synLocRadius, cfg.synLocMiddle+cfg.synLocRadius, cfg.numExSyns/2)), 'sec': 'basal_8', 'synMech': ['NMDA'],
                    'start': cfg.synTime+1600, 'interval': 1000, 'noise': 0.0, 'number': 1, 'weight': cfg.glutAmp * cfg.glutAmpExSynScale, 'delay': cfg.exSynDelay, 'radius' : 0.15, 'nSyns' : 24}
cfg.glutPuffSyn4 = {'loc': list(np.linspace(cfg.synLocMiddle-cfg.synLocRadius, cfg.synLocMiddle+cfg.synLocRadius, cfg.numSyns/2)), 'sec': 'basal_8', 'synMech': ['NMDA','AMPA'],
                    'start': cfg.synTime+2400, 'interval': 1000, 'noise': 0.0, 'number': 1, 'weight': cfg.glutAmp, 'delay': cfg.synDelay, 'radius' : 0.2, 'nSyns' : 24}
cfg.glutPuffExSyn4 = {'loc': list(np.linspace(cfg.synLocMiddle-cfg.synLocRadius, cfg.synLocMiddle+cfg.synLocRadius, cfg.numExSyns/2)), 'sec': 'basal_8', 'synMech': ['NMDA'],
                    'start': cfg.synTime+2400, 'interval': 1000, 'noise': 0.0, 'number': 1, 'weight': cfg.glutAmp * cfg.glutAmpExSynScale, 'delay': cfg.exSynDelay, 'radius' : 0.2, 'nSyns' : 24}
cfg.glutPuffSyn5 = {'loc': list(np.linspace(cfg.synLocMiddle-cfg.synLocRadius, cfg.synLocMiddle+cfg.synLocRadius, cfg.numSyns/2)), 'sec': 'basal_8', 'synMech': ['NMDA','AMPA'],
                    'start': cfg.synTime+3200, 'interval': 1000, 'noise': 0.0, 'number': 1, 'weight': cfg.glutAmp, 'delay': cfg.synDelay, 'radius' : 0.25, 'nSyns' : 24}
cfg.glutPuffExSyn5 = {'loc': list(np.linspace(cfg.synLocMiddle-cfg.synLocRadius, cfg.synLocMiddle+cfg.synLocRadius, cfg.numExSyns/2)), 'sec': 'basal_8', 'synMech': ['NMDA'],
                    'start': cfg.synTime+3200, 'interval': 1000, 'noise': 0.0, 'number': 1, 'weight': cfg.glutAmp * cfg.glutAmpExSynScale, 'delay': cfg.exSynDelay, 'radius' : 0.25, 'nSyns' : 24}
*** FIGURE: [[EEE_dend8_center03_synSyns24_differentRadii.png][doesn't realy matcg up w/ more clustred == better]]
*** FIGURE: [[EEE_dend8_center03_synSyns24_differentRadii_trace.png][traces for above]]

* [2019-9-4 Wed]
** increasing weights for gasparini magee stims in PT cell to get spikes

* [2019-9-5 Thu] - back to gasparini magee style inputs w/ PT cell
** yesterday, played around w/ increased weight (0.25)
*** AMPA + NMDA, no extrasynaptic NMDA
*** may want to also look into just AMPA
** TODO: look at backpropagating APs and dendritic spikes 
*** Clustered: for 50ms - 10040-10060, -70-0; for 1ms - 15990 - 16060, -70-0
plt.subplot(121); plt.plot(time[10040:10060], soma[10040:10060],'b',label='Soma')
plt.plot(time[10040:10060], dend[10040:10060],'r',label='Dendrite')
plt.xlabel('Time (ms)'); plt.ylabel('Voltage (mV)')
plt.legend(); plt.title('50ms Window')

plt.subplot(122); plt.plot(time[15990:16060], soma[15990:16060],'b',label='Soma')
plt.plot(time[15990:16060], dend[15990:16060],'r',label='Dendrite')
plt.xlabel('Time (ms)'); plt.ylabel('Voltage (mV)')
plt.title('1ms Window'); plt.legend()
plt.show()
*** Sampling frequency too low to see which is first, soma or dend, increasing by 10x
plt.subplot(121); plt.plot(time[30450:30650], soma[30450:30650],'b',label='Soma')
plt.plot(time[30450:30650], dend[30450:30650],'r',label='Dendrite')
plt.xlabel('Time (ms)'); plt.ylabel('Voltage (mV)')
plt.legend(); plt.title('50ms Window')

plt.subplot(122); plt.plot(time[39900:40500], soma[39900:40500],'b',label='Soma')
plt.plot(time[39900:40500], dend[39900:40500],'r',label='Dendrite')
plt.xlabel('Time (ms)'); plt.ylabel('Voltage (mV)')
plt.title('1ms Window'); plt.legend()
plt.show()
*** posted figure on slack:
billl 12:03 PM
tau in our dend seems very very fast??
Craig 12:06 PM
going by the time difference between AP and backprop AP?
or just the rise times in general?
billl 12:14 PM
i'm surprised by instant rise in dend in R panel from your sim
Craig 12:15 PM
oh, that was fom 120 synatpic stims w/in 1ms
billl 12:15 PM
what is taum at dend location? -- reasonable value?
Craig 12:20 PM
i'll check
Craig 2:06 PM
let me make sure I have this right for finding taum: I did a 0.05 nA current injection, got a steady state voltage change of ~39mV, used those to get a membrane resistance of 792MOhm, multiply that by membrane capacitance: taum = RC = 821
billl 2:09 PM
821ms?? -- sounds wrong
direct measure is to look at the time taken to get to 1-e level
Craig 2:19 PM
time to Vinf*(1-e)?
or (Vinf-Vbaseline)*(1-e)
billl 2:20 PM
yeah that seems right -- till get ~63% of the time up -- that shold be == to RC as you said before
Craig 2:25 PM
reaches >63% within 1 sample, and the sampling step is 0.1 ms
billl 2:26 PM
that's not so good -- instantaneous ... generally recommended dt is 0.025 and for somethig like this will want to also sample at 0.025
but clearly something is amiss
Craig 2:30 PM
just as a sanity check, here's the trace for part of the current injection
billl 2:31 PM
that's like superinsane man
how long is the Iin btw?
Craig 2:31 PM
the lin?
billl 2:31 PM
input current
Craig 2:31 PM
x-axis is in samples btw
billl 2:32 PM
oh should do as time np.linspace(...
Craig 2:32 PM
oh, wait, that is time
billl 2:32 PM
ok
Craig 2:33 PM
but the IClamp amplitude is 0.05
which i believe is in nA
billl 2:33 PM
in general would want smaller since in an active cell don't want to trigger stuff -- also usually would do hype not depol to measure
since most of the active stuff except for anomalous rectifier will go off with depol
Craig 2:34 PM
OK
I'll go through it w/ a smaller negative injection
but do you still think something's amiss regardless?
billl 2:41 PM
yes i think so
which cell are we on here?  eee?
Craig 2:43 PM
Pyramidal tract
billl 2:44 PM
that's from basilar dend?
what's the Rin/taum in soma?
your rin there you said was 800 Mohms so seems not bad
Craig 2:45 PM
It is, and Iâ€™ll look
*** working on issues of tau and gmax
** TODO: look at spike count and/pr frequency vs integration window

* [2019-9-6 Fri] - why is tau so small (PT cell)
** what's up with time constant
*** passive conductances:
In [1]: sim.net.cells[0].secs['dend_52']['mechs']['pas']['g']
Out[1]: 1.9249571596707396e-05
In [2]: sim.net.cells[0].secs['soma']['mechs']['pas']['g']
Out[2]: 2.6002771322815988e-05
*** from *PTcell.hoc*:
rm          = 38457.4393085
spinecapfactor = 1.48057846279
...
proc optimize_nseg () { // Ra, cm, spinecapfactor
    // use worst case Ra, cm values
    forall {
        Ra = $1
        cm = $2
    }
    forsec spiny {
        cm = $3 * cm  // spinecapfactor * cm
        g_pas = $3 / rm // spinecapfactor * (1.0/rm)
    }
    // optimize # of segments per section (do this afer setting Ra, cm)
    geom_nseg()
    // need to reassign distances after changing nseg
    recalculate_x_dist()
}
...
forsec spiny {
    cm = spinecapfactor * cm
    // Adjust g_pas to compensate, to keep same time constant
    // This is new as of 2011-02-14, because last week Michele Migliore said that
    // the idea of a spine factor is to "add more membrane".
    // I'm not sure about this, though, I thought I saw models that just
    // increase the capacitance.
    g_pas = spinecapfactor / rm
}
*** turns out time constant from dend_52 at loc=0.5 is ~5ms 
** looking at dendritic spike
*** w/ and w/out TTX 
*** fewer stims

* [2019-9-9 Mon] - dendritic spikes from clustered inputs
** Returning to dendritic spikes
*** looking for number of stims where dendritic spike leads to somatic spike
*** clustered, synchronous (1ms) inputs (dend_52 - dend_55)
**** FIGURE: [[./firstSomaSpikeFromDendSpike.png][90 synchronous, spatially clustered inputs.  First time getting soma when increasing N_inputs by 10]]
**** FIGURE: [[./dendSpikeWithDropOff.png][30 synchronous, spatially clustered inputs.  Dendritic voltage falls off quickly after spike]]
**** FIGURE: [[./dendSpikeWithPlateau.png][60 synchronous, spatially clustered inputs.  Dendritic voltage plateaus briefly after spike]]
**** FIGURE: [[./spatiallyAndTemporallyClusteredInputs_dendriticSpikes.png][composite figure]]
**** FIGURE: [[./spatiallyAndTemporallyClusteredInputs_dendriticSpikes.png][composite figure zoomed in on initial dendritic spikes]]
*** where exactly do dendritic spike start?
**** FIGURE: [[./whereDendSpikesBegin.png][10-30 inputs, see dendritic spikes start ~20 inputs]]
*** where exactly do somatic spikes start?
**** ran inputs from n_choices = np.linspace(90,110,21)
**** when exactly you get a somatic spike seems to depend on spatiotemporal distribution of inputs
**** seems to be systematic time difference between dendritic spike and somatic spike
start = 3500
dend = np.array(sim.simData['dend_52']['cell_0'])
soma = np.array(sim.simData['V_soma']['cell_0']) 
time = np.array(sim.simData['t'])
starts = []
from scipy.signal import find_peaks
for choice in choices[3:]:
    starts.append(start)
    start = start + 1000
timeDiff = []
for choice in n_choices:    
    startInd = np.where(n_choices==choice)[0][0]
    startTime = starts[startInd]
    startTimeInd = np.argmin(np.square(time-(startTime-100)))
    endTimeInd = np.argmin(np.square(time-(startTime+800)))
    dend_pks = find_peaks(dend[startTimeInd:endTimeInd],-25)
    soma_pks = find_peaks(soma[startTimeInd:endTimeInd],-20)
    dendSpkTime = time[dend_pks[0][0] + startTimeInd]
    somaSpkTime = time[soma_pks[0][0] + startTimeInd]
    timeDiff.append(somaSpkTime-dendSpkTime)
**** FIGURE: [[./timeDiffDendriticSpikeToSomaticSpike.png][sweep on N_inputs, time between dendritic spike and somatic spike]]
** PAPER: Ben-Shalom et al. Inferring neuronal ionic conductances from membrane potentials using CNNs (Kristofer Bouchard)
*** used electrophysiology Feature Extraction Library (eFEL): (Blue Brain Project. Electrophys feature extraction library (efel, github), 2019.)
*** CNN Workflow:
**** chirp stimulus into cell model
**** resulting waveform and cell params form CNN training set
**** fed into 32 separate CNNs (same architecture, different initialization of weights, and processes training sets in different order)
**** those output params fed into neuron simulation to generate output waveform and compare w/ ground truth
*** three models: izhikevich [4 params], hodgkin-huxley [7 params], mainen-sejnowski [10 params]
*** Interesting normalization method: "The natural amplitude of the membrane potential varied between [âˆ’80, 50] mV. Since we expect the non-spiking portion of a trace to contain more
information about ionic channels, we shifted each trace so that its minimum value was +1mV and took the logarithm. This guarantees that the range of input values X 0 is limited to [0,3] and only a small fraction of this range
is designated to neuron spikes. Also, it reduces sensitivity to the drift of holding current, which is expected to vary between stimulations. The dimension of X(t) was 9000 time bins."
*** CNN outperforms Multi-Objective Optimization
*** Drawback: "The most challenging to predict were parameters that were highly correlated, either due to having the same conductances in several compartments or several conductances at 
the same compartment that control the same ion flux. This issue was more prevalent as the complexity of the models increased."
*** Improvements: "
i) Adding more stimulation to generate a more versatile response from the neuronal simulator
ii) recording from additional locations on the neuron, either using the cell attached configuration [27] or direct voltage imaging of the entire cell
iii) reducing the dimensionality by only predicting sub-groups of the varied parameters and pharmacologically blocking other conductances as described here"

* [2019-9-10 Tue] - more of the same
** fleshed out taum at dendrite for PT cell (see [2019-9-6 Fri])
*** FIGURE: [[./dend52_taumPlot.png][current injection, amp = 0.01, line at 68% of deltaV]]
** EEE meeting:
*** Clustered versus distributed inputs
**** Glutamate puff hits basal_8 (len = 166.3 um, nseg=3)
**** Default num syns = 24
**** Default loc = 0.3
**** Default rad = 0.15
**** So 24 synapses are spread from 0.15 to 0.45
**** Weight is evenly distributed amongst synapses
**** Synaptic density is not constant in this setup
***** This setup was to match experimental data
***** Should set a constant synaptic density to explore clustering?
**** Location has more effect that spread (see Figure 1) 
**** Glutamate puff incongruities (Craig?)
**** Craig looking into resonance effects, was just looking at clustering to ensure heâ€™s getting the same output as we got before
***** Craig comparing same number of synapses and weights, but either in the cluster or spread throughout basal arborization
***** Craig looking at time windows 
***** Good progress towards poster (even if negative results)
***** For a resonance effect, inputs must be spread out
***** Srdjan: concerned weâ€™re getting plateaus even without clustering
*** DONE: look at massive error bars for distributed inputs at 250ms
import numpy as np 
import json
from os import listdir
from os.path import isfile, join
from matplotlib import pyplot as plt 
from scipy.signal import find_peaks 

base_path = '/oasis/scratch/comet/ckelley/temp_project/glutPuffBatches/'
datafiles = [f for f in listdir(base_path) if isfile(join(base_path, f))]

start = 35000
for count, filename in enumerate(datafiles):
    with open(base_path+filename,'r') as fileObj:
        data = json.load(fileObj)
    fig = plt.figure(figsize=(16,10))
    t = np.array(data['time']); v = np.array(data['axon'])
    pks = find_peaks(v[start:start+1000],-20)
    spk_count = len(pks[0])
    plt.plot(t[start-200:start+1000], v[start-200:start+1000])
    plt.xlabel('Time (ms)')
    plt.ylabel('Membrane Potential (mV)')
    plt.title('Run #'+str(count)+ ': ' + str(spk_count) + ' spikes')
    fig.savefig(base_path+'figs/fig_'+str(count)+'.png')
    del(fig)
*** FIGURES: [[../EEE_network/eee_single/][folder containing figures from 50 runs, 24 randomly placed on whole basal arbor stims w/in 250ms, errorbar from analysis looks right]]

* [2019-9-11 Wed] - more of EEE and PT
** Still looking at why such high variation at 250ms window
*** previous sims used extrasynaptic NMDA, even for distributed. - try turning off for all and for just distributed.
**** should weight of extrasynaptic NMDA stims be proportional to the radius of cluster?
*** running sims w/ no extrasynaptic NMDA for distributed inputs and sims w/ none at all on comet
**** output folder (none at all): /oasis/scratch/coemt/ckelley/temp_project/glutPuffBatchesNoExSyn/
**** output folder (none when distributed): /oasis/scratch/coemt/ckelley/temp_project/glutPuffBatchesGoodExSyn/
*** (none when distributed) FIGURE: [[../EEE_network/eee_single/EEE_spkCountVsWindowSize_goodExSyn.png][three distributions, 50 sweeps through window sizes, only extrasynaptic NMDA for clustered/branch]]
*** (none) FIGURE: [[../EEE_network/eee_single/EEE_spkCountVsWindowSize_noExSyn.png][three distributions, 50 sweeps through window sizes, no extrasynaptic NMDA]]
*** high variation window switches to 100 ms . . . 
*** DONE: look at massive error bars for distributed inputs at 250ms
import numpy as np 
import json
from os import listdir
from os.path import isfile, join
from matplotlib import pyplot as plt 
from scipy.signal import find_peaks 

base_path = '/oasis/scratch/comet/ckelley/temp_project/glutPuffBatchesGoodExSyn/'
datafiles = [f for f in listdir(base_path) if isfile(join(base_path, f))]

start = 37000
for count, filename in enumerate(datafiles):
    with open(base_path+filename,'r') as fileObj:
        data = json.load(fileObj)
    fig = plt.figure(figsize=(16,10))
    t = np.array(data['time']); v = np.array(data['axon'])
    pks = find_peaks(v[start:start+1000],-20)
    spk_count = len(pks[0])
    plt.plot(t[start-200:start+1000], v[start-200:start+1000])
    plt.xlabel('Time (ms)')
    plt.ylabel('Membrane Potential (mV)')
    plt.title('Run #'+str(count)+ ': ' + str(spk_count) + ' spikes')
    fig.savefig(base_path+'figs/fig_'+str(count)+'.png')
    del(fig)
*** plotting traces:
import json
import numpy as np
from matplotlib import pyplot as plt
with open('eeeCell_v0.json','r') as fileObj:
    data = json.load(fileObj)
start = 5000
starts = [start]
windows = [500, 250, 100, 50, 25, 10, 1]
for window in windows:
    start = start+2000
starts.append(start)
for window in windows:
     start = start+2000
starts.append(start)
starts = np.array(starts)
time = np.array(data['time'])
v = np.array(data['axon'])
count = 1
fig = plt.figure(figsize=(16,10))
for window in windows:
    plt.subplot(2,3,count)
    if window == 500:
        plt.plot(time[starts[2]-100:starts[2]+800]-(starts[2]-100),v[starts[2]-100:starts[2]+800],'y',label='Basal Arbor')
        plt.plot(time[starts[1]-100:starts[1]+800]-(starts[1]-100),v[starts[1]-100:starts[1]+800],'b',label='radius=0.44')
        plt.plot(time[starts[0]-100:starts[0]+800]-(starts[0]-100),v[starts[0]-100:starts[0]+800],'r',label='radius=0.15')    
        count = count + 1
    elif window == 250:
        plt.plot(time[starts[2]-100:starts[2]+500]-(starts[2]-100),v[starts[2]-100:starts[2]+500],'y',label='Basal Arbor')
        plt.plot(time[starts[1]-100:starts[1]+500]-(starts[1]-100),v[starts[1]-100:starts[1]+500],'b',label='radius=0.44')
        plt.plot(time[starts[0]-100:starts[0]+500]-(starts[0]-100),v[starts[0]-100:starts[0]+500],'r',label='radius=0.15')
        count = count + 1
    elif window != 50:
        plt.plot(time[starts[2]-100:starts[2]+400]-(starts[2]-100),v[starts[2]-100:starts[2]+400],'y',label='Basal Arbor')
        plt.plot(time[starts[1]-100:starts[1]+400]-(starts[1]-100),v[starts[1]-100:starts[1]+400],'b',label='radius=0.44')
        plt.plot(time[starts[0]-100:starts[0]+400]-(starts[0]-100),v[starts[0]-100:starts[0]+400],'r',label='radius=0.15')
        count = count + 1
    if window !=50:
        plt.xlabel('Time (ms)')
        plt.ylabel('Membrane Potential (mV)')
        plt.ylim((-90,50))
        if window == 100:
            plt.legend()
        plt.title('Run #0 - Window Size: ' + str(window) + ' ms')
    starts = starts + 2000
fig.savefig('/home/craig/Documents/Neurosim_Lab/dendritic_resonance/EEE_trace_figs/run0ttx_traces.png')

# plt.plot(time[starts[2]-200:-100]-(starts[2]-200),v[starts[2]-200:-100],'y',label='Basal Arbor')
# plt.plot(time[starts[1]-200:starts[2]-100]-(starts[1]-200),v[starts[1]-200:starts[2]-100],'b',label='radius=0.44')
# plt.plot(time[starts[0]-200:starts[1]-100]-(starts[0]-200),v[starts[0]-200:starts[1]-100],'r',label='radius=0.15')
# plt.xlabel('Time (ms)')
# plt.ylabel('Membrane Potential (mV)')
# plt.title('Run #10')
# plt.ylim((-90,50))
# plt.legend()
# plt.show()

** Looking for spiking resonance in PT cell
*** find reliable number of stims for spiking
**** huge difference between number of stims w/ EEE cell vs number of stims w/ PT cell ....

* [2019-9-12 Thu] - fleshing out EEE cell data
** plotting traces for EEE cell
*** FIGURE: [[../EEE_network/eee_single/run0goodExSyn_traces.png][Overlaid traces of 2 clustered (w/exSynNMDA) runs and 1 distributed (w/out exSynNMDA)]]
*** FIGURE: [[../EEE_network/eee_single/run0goodExSyn_traces.png][Overlaid traces of 2 clustered runs and 1 distributed, no exSynNMDA]]
*** billl 11:03 AM - basal arbor means across all basal dends? -- looks like getting more plateau that way (contrary to hypo)
** to address bill's comment - running w/ TTX
*** original TTX code didn't work:
for secName, sec in netParams.cellParams['eeeD']['secs'].items(): 
    if cfg.ttx:
        sec['mechs']['nax']['gbar'] = 0.0
*** needed to switch to 
for secName, sec in netParams.cellParams['eeeD']['secs'].items(): 
    if cfg.ttx:
        sec['mechs']['na']['gbar'] = 0.0
**** running on comet, output folder: /oasis/scratch/comet/ckelley/temp_project/glutPuffBatchesGoodExSynTTX/
**** ... sitting in the queue forever
*** single run done locally:
**** basal arbor syn locations:
[['basal_1', 0.44999999999999996],
 ['basal_27', 0.2152173913043478],
 ['basal_31', 0.2152173913043478],
 ['basal_18', 0.3456521739130434],
 ['basal_9', 0.20217391304347826],
 ['basal_26', 0.26739130434782604],
 ['basal_21', 0.26739130434782604],
 ['basal_4', 0.3195652173913043],
 ['basal_19', 0.3326086956521739],
 ['basal_18', 0.35869565217391297],
 ['basal_5', 0.24130434782608695],
 ['basal_31', 0.22826086956521738],
 ['basal_27', 0.2543478260869565],
 ['basal_21', 0.2804347826086956],
 ['basal_20', 0.37173913043478257],
 ['basal_35', 0.16304347826086957],
 ['basal_24', 0.1891304347826087],
 ['basal_0', 0.1760869565217391],
 ['basal_2', 0.37173913043478257],
 ['basal_18', 0.41086956521739126],
 ['basal_23', 0.22826086956521738],
 ['basal_22', 0.2543478260869565],
 ['basal_16', 0.3456521739130434],
 ['basal_23', 0.2543478260869565]]
**** code for plotting:
import numpy as np
from matplotlib import pyplot as plt
start = 500
starts = [start]
windows = [500, 250, 100, 50, 25, 10, 1]
for window in windows:
    start = start+2000
starts.append(start)
for window in windows:
     start = start+2000
starts.append(start)
starts = np.array(starts)
time = np.array(sim.simData['t'])
# v = np.array(sim.simData['V_soma_0']['cell_0'])
v = np.array(sim.simData['V_dend_8']['cell_0'])
count = 1
fig = plt.figure(figsize=(16,10))
for window in windows:
    plt.subplot(2,3,count)
    if window == 500:
        plt.plot(time[starts[2]-100:starts[2]+800]-(starts[2]-100),v[starts[2]-100:starts[2]+800],'y',label='Basal Arbor')
        plt.plot(time[starts[1]-100:starts[1]+800]-(starts[1]-100),v[starts[1]-100:starts[1]+800],'b',label='radius=0.44')
        plt.plot(time[starts[0]-100:starts[0]+800]-(starts[0]-100),v[starts[0]-100:starts[0]+800],'r',label='radius=0.15')    
        count = count + 1
    elif window == 250:
        plt.plot(time[starts[2]-100:starts[2]+500]-(starts[2]-100),v[starts[2]-100:starts[2]+500],'y',label='Basal Arbor')
        plt.plot(time[starts[1]-100:starts[1]+500]-(starts[1]-100),v[starts[1]-100:starts[1]+500],'b',label='radius=0.44')
        plt.plot(time[starts[0]-100:starts[0]+500]-(starts[0]-100),v[starts[0]-100:starts[0]+500],'r',label='radius=0.15')
        count = count + 1
    elif window != 50:
        plt.plot(time[starts[2]-100:starts[2]+400]-(starts[2]-100),v[starts[2]-100:starts[2]+400],'y',label='Basal Arbor')
        plt.plot(time[starts[1]-100:starts[1]+400]-(starts[1]-100),v[starts[1]-100:starts[1]+400],'b',label='radius=0.44')
        plt.plot(time[starts[0]-100:starts[0]+400]-(starts[0]-100),v[starts[0]-100:starts[0]+400],'r',label='radius=0.15')
        count = count + 1
    if window !=50:
        plt.xlabel('Time (ms)')
        plt.ylabel('Membrane Potential (mV)')
        plt.ylim((-90,21))
        if window == 100:
            plt.legend()
        plt.title('Run #0 - Window Size: ' + str(window) + ' ms')
    starts = starts + 2000
plt.show()

* [2019-9-16 Mon] - revisiting chirp resonance
** Amplitude of original chirp* runs very small, trying different lengths of stim, amplitude, and frequency ranges
*** for basal dends *amp = 0.1* works well

* [2019-9-17 Tue] - more chirp
** CA1 cell, no real resonance
*** CA1 parameters:
PYRcell.radTprox(0.1).hd.gbar
0.0001
PYRcell.radTprox(0.1).hd.elk
-65.61
PYRcell.radTprox(0.1).hd.glk
0.0
PYRcell.radTprox(0.1).hd.i
-0.00014645946219307604
PYRcell.radTprox(0.1).hd.is_ion()
False
PYRcell.radTprox(0.1).hd.l
0.03796800066895462
PYRcell.radTprox(0.1).hd.lk
-0.0002075111911178861
PYRcell.radTprox(0.1).hd.clk
0.7
*** PT cell parameters:
pt_cell.dend[5](0.9).hd.glk
0.
pt_cell.dend[5](0.9).hd.clk
0.
pt_cell.dend[5](0.9).hd.gbar
6.0465404417424175e-05
pt_cell.dend[5](0.9).hd.i
0.
pt_cell.dend[5](0.9).hd.vhalfl
-82.
pt_cell.dend[5](0.9).hd.ehd
-30.
pt_cell.dend[5](0.9).hd.lk
0.0
pt_cell.dend[5](0.9).hd.elk
-65.61

* [2019-9-18 Wed] - again, more chirp
** setting up batch files for all basal locations
*** FILE: *chirpResonanceCluster.py* - v0.0 - chirp for basal dends
*** testing one on comet to make sure things work: basal-29-0.625
*** ran all basal segments on comet, output folder: /oasis/scratch/comet/ckelley/temp_project/chirp_dends/

* [2019-9-19 Thu] - fleshing out PT cell chirp
** Looking at how transfer resonance changes along single branch
*** FILE: *alongOneDend.py* - v0.0 - adapted chirp stim to record all segments along single branch 
**** results interesting, but very different from some other basal sections I've looked at, going back to plot
Basal-46:
resFreqCis = 35.0909
resFreqSoma = 18.9637 
**** got dendritic spikes at basal-46
*** sweeping through current injection amplitudes w/ basal-46, peak frequency shifts with amplitude

* [2019-9-20 Fri] - " "
** peak does change, doing more detailed sweep through
*** doing an even more detailed sweep
*** running on 46 locally, 4 on el
*** need to run *plt.switch_backend('agg')* for generating figs on neurosim
** trying with Ih removed

* [2019-9-23 Mon] - basal dend resonance
** amplitude sweep looks great, but legend was messed up, rerunning now on el 
*** FIGURE: [[./chirpAmpSweep/ptCell_basal46_ampSweep.png][sweep over very small amplitude range where secondary resonant peak emerges]]
*** finished rerunning, looks good
** comparisons of w/ and w/out Ih
*** FIGURE: [[./ampSweepv2/basal46_amp0.045.png][w/ Ih, peaks at 5.7 and 6.3 Hz for dend and soma respectively]]
*** FIGURE: [[./ampSweepv2/ptCell_basal46_amp0.04604_v2.png][w/ Ih, , peaks at ~11.6 for both]]
*** FIGURE: [[./ampSweepv2/removIh_basal46_amp0.045.png][as name imples, no peaks]]
*** FIGURE: [[./ampSweepv2/removIh_basal46_amp0.04604.png][as name imples, no peaks]]
** w/out Na, second peak where dend spiking starts goes away
*** FIGURE: [[./ampSweepv2/removNa_basal46_amp0.04604.png][dendritic spike peak goes away]]

* [2019-9-24 Tue] - chirp in EEE cell
** got chirp protocol working in EEE cell, resonant freequency ~4 Hz
** played around to look for where dendritic spikes begin, and appears to be at 4Hz

* [2019-9-25 Wed] - PT cell different branch, more EEE cell
** looking at basal-4, appears that dendritic spikes are centered on a different frequency than previous branch-46
*** running amplitude sweep on pt
** running EEE cell amplitude sweep on neurosim machines (el)

* [2019-9-27 Fri] - more PT cell
** making some presentable figs for basal branch
** looking at an apical oblique, apic-88, on pt
*** switched to el
*** on pt, job fails when importing matplotlib
*** also failed for same reason w/ ipython on el - trying again w/ nrniv -python

* [2019-9-28 Sat] - looking through apical sections
** increasing amplitude for apical oblique, sweeping through a few on pt
*** rerunning oblique at 100pA, going up to 50 Hz
** looking at apical main trunk on el

* [2019-9-29 Sun] - all along main trunk
** arc length to soma for neuron:
loc_num = 0.5
norm3d = np.linspace(0,1,sec.n3d())
ind3d = np.argmin((norm3d - loc_num)**2)
arc_loc = sec.arc3d(ind3d)
total_arc = arc_loc
parent_seg = sec.trueparentseg().sec
parent_seg_name = parent_seg.name().split('.')[1][:4]
while parent_seg_name != 'soma':
    print(parent_seg_name)
    sec = parent_seg
    total_arc = total_arc + sec.arc3d(sec.n3d()-1)
    parent_seg = sec.trueparentseg().sec
    parent_seg_name = parent_seg.name().split('.')[1][:4]

soma3d = np.linspace(0,1,parent_seg.n3d())
indsoma = np.argmin((soma3d - 0.5) **2)
total_arc = total_arc + (parent_seg.arc3d(parent_seg.n3d()-1) - parent_seg.arc3d(indsoma))
print(total_arc)

* [2019-9-30 Mon] - apical chirp stims
** stims on apical main trunk
*** still running on pt from last night
*** looks like fairly gradual changes in res freq
*** output figs: /u/craig/M1_Res/maintrunk_figs/
*** finished running, need to plot output
** revisiting EEE cell
*** looking at apical segments
*** apical-6 had peak ~5Hz, increases to ~6Hz for apical-11, ~7Hz for apical-13
*** need to drop amplitude moving away from soma to prevent spikes . . . seems paradoxical
*** trying all on main trunk on el
** playing around w/ IT cell
*** couldn't import Cell3D - /usr/site/nrniv/local/python/Cell3D.py

* [2019-10-4 Fri] - been putting figures together for poster last few dynamics 
** installing jNeuroML
*** git clone git://github.com/NeuroML/jNeuroML.git neuroml_dev/jNeuroML
*** cd neuroml_dev/jNeuroML
*** python getNeuroML.py development
*** Executing: (git clone https://github.com/LEMS/jLEMS) in dir: ..
*** Cloning into 'jLEMS'...
*** remote: Enumerating objects: 39, done.
*** remote: Counting objects: 100% (39/39), done.
*** remote: Compressing objects: 100% (29/29), done.
*** remote: Total 9920 (delta 10), reused 22 (delta 4), pack-reused 9881
*** Receiving objects: 100% (9920/9920), 6.74 MiB | 4.23 MiB/s, done.
*** Resolving deltas: 100% (3885/3885), done.
*** Switching to branch: development
*** >>>  Executing: (git checkout development) in dir: ../jLEMS
*** Switched to a new branch 'development'
*** >>>  Executing: (git branch) in dir: ../jLEMS
*** ''* development
***   master
*** >>>  Executing: (git pull) in dir: ../jLEMS
*** It's a Java repository, so installing using Maven...
*** >>>  Executing: (mvn install) in dir: ../jLEMS
*** /bin/sh: 1: mvn: not found
*** Error: 127
*** b''
*** successfully installed, but haven't figure out how to use BBP models
** FIGURES
*** [[./basa_example.png][example of chirp stimulus on a basal branch]]
*** [[./apical_oblique_example.png][example of chirp stimulus on an apical oblique branch]]
*** [[./apical_trunk.png][analysis showing resonant frequency and peak impedance changing along the main apical trunk]]
*** [[./sodium_ih_example.png][two current amplitudes, one with Na spikelets, unaltered, without Na, without Ih]]
*** [[./sodium_ih_example2.png][same as above sans w/out Ih]]

* [2019-10-6 Sun] - fleshing out na spikelets thing
** recording sodium current:
na_curr.record(pt_cell.dend[12](0.5).nax._ref_ina)

* [2019-10-7 Mon] - more na spikelets, running all secs
** running all secs on *pt* for PT cell at low enough amplitude for no na spikelets 
** looking at Na spikelets
*** playing around with dend-4, where spikelets begin at a different frequency than previous example

* [2019-10-11 Fri] - poster summary 
** Methods FIGURES:
*** [[../sfn_poster_2019/eeeCell_forMethods.png][plot of EEE cell with syns on basal_8 at 0.5 and soma_1 at 0.5]]
*** [[../sfn_poster_2019/dendTrace][example voltage trace from EEE cell at basal_8, current amplitude = 0.045nA]]
*** [[../sfn_poster_2019/somaTrace][example voltage trace from EEE cell at soma_1, current amplitude = 0.045nA]]
*** [[../sfn_poster_2019/current_examp.png][example current trace at ampliutde = 0.045nA]]
*** [[../sfn_poster_2019/composite_methods_figure.png][composite of above figures]]
** Results FIGURES
*** resonance mapped to location
**** FIGURE:[[../sfn_poster_2019/eeeCell_somaPlotShape.png][peak frequency at soma mapped to stimulated section]]
**** FIGURE:[[../sfn_poster_2019/eeeCell_cisPlotShape.png][peak frequency at stimulated section mapped to that section]]
**** FIGURE:[[../sfn_poster_2019/ptCell_transferToSoma_shapePlot.png][peak frequency at soma mapped to stimulated section]]
**** FIGURE:[[../sfn_poster_2019/ptCell_resOnDend_shapePlot.png][peak frequency at stimulated section mapped to that section]]
**** code:
from netParams_cell1 import netParams 
from cfg_cell1 import cfg 
from netpyne import sim, specs
import json

sim.create(netParams, cfg)

res_values = []
soma_res_values = []

for sec in sim.net.cells[0].secLists['all']:
    nseg = sim.net.cells[0].secs[sec]['geom']['nseg']
    # if (sec == 'soma') | (sec == 'axon'):
    if (sec == 'soma'):
        for i in range(nseg):
            res_values.append(2)
            soma_res_values.append(2)
    # else:
    elif (sec != 'axon'):
        with open('/pt/u/'+sec+'.json','r') as fileObj:
            data = json.load(fileObj)
        for i in range(nseg):
            res_values.append(data['resFreqCis'])
            soma_res_values.append(data['resFreqSoma'])

sim.analysis.plotShape(cvals=res_values, includeAxon=False)
**** data folders for these:
***** PT cell: [[./chirp_dends/][basic summary data for current injections at all sections with current amplitude = 0.03 nA]] 
***** EEE cell: [[../EEEnetwork/eee_single/chirp_dends][basic summary data for current injections at all sections with current amplitude = 0.045 nA]]
*** PT Cell Examples:
**** FIGURE: [[../sfn_poster_2019/apical_tuft_example.png][apic_60, current amp = 45pA]]
**** FIGURE: [[../sfn_poster_2019/apical_oblique_example.png][apic_88, current amp = 45pA]]
**** FIGURE: [[../sfn_poster_2019/basal_example.png][dend_32, current amp = 45pA]]
**** FIGURE: [[../sfn_poster_2019/apical_trunk.png][current amp = 45pA]]
**** FIGURE: [[../sfn_poster_2019/apical_tuft_example.fig][apic_60, current amp = 45pA]]
**** FIGURE: [[../sfn_poster_2019/apical_oblique_example.fig][apic_88, current amp = 45pA]]
**** FIGURE: [[../sfn_poster_2019/basal_example.fig][dend_32, current amp = 45pA]]
**** FIGURE: [[../sfn_poster_2019/eeeCell_apical_trunk.fig][current amp = 45pA]]
*** EEE CEll Examples:
**** FIGURE: [[../sfn_poster_2019/EEEcell_apicalTuft_example.png][apical_15, current amp = 45pA]]
**** FIGURE: [[../sfn_poster_2019/eeeCell_apical_oblique_example.png][apic_34, current amp = 45pA]]
**** FIGURE: [[../sfn_poster_2019/eeeCell_basal_example.png][dend_32, current amp = 45pA]]
**** FIGURE: [[../sfn_poster_2019/eeeCell_apical_trunk.png][current amp = 45pA]]
**** FIGURE: [[../sfn_poster_2019/EEEcell_apicalTuft_example.fig][apical_15, current amp = 45pA]]
**** FIGURE: [[../sfn_poster_2019/eeeCell_apical_oblique_example.fig][apic_34, current amp = 45pA]]
**** FIGURE: [[../sfn_poster_2019/eeeCell_basal_example.fig][dend_32, current amp = 45pA]]
**** FIGURE: [[../sfn_poster_2019/eeeCell_apical_trunk.fig][current amp = 45pA]]
*** Sodium Spikelets:
**** FIGURE: [[../sfn_poster_2019/sodium_spikelets_dend4.png][48.5pA]]
**** FIGURE: [[../sfn_poster_2019/sodium_spikelets_dend46.png][46pA]]

* [2019-10-12 Sat] - rerunning apical trunk on pt cell
** UPDATE: [[./chirpMainTrunk.py][changed length of stim from 50 - 20 secs]]

* [2019-10-14 Mon] - resonance poster revisited
** notes on poster from bill
*** channel densitites between cells Methods
**** channels on trunk - EEE
***** *gkabar_kap decreases* with distance to soma (pretty linearly)
***** *gkabar_kad increases* with distance to soma (pretty linearly)
***** *gbar_ca constant*
***** *gbar_it constant*
***** *gIhbar_Ih increases* pretty similarly to resonant frequency
**** channels on trunk - M1
***** *gbar_kdr constant*
***** *gbar_kap constant*
*** colormaps for summary figures
*** move summary figures
*** for tufts, look at nexus, top of trunk
**** corticospinal: 77-tuft, 52-nexus, 32-other tuft
**** eee: 13-tuft, 8-nexus, 32-other tuft
*** DONE: removing/add channels figures
*** DONE: add transfer to trunk figures 

* [2019-10-16 Wed] 
** added impedance for removal of K+(A)
** pretty clear resonance frequency varies with Ih
** still working out why local impedance vs distance from soma differs
*** was wrong about diameters being constant
*** EEE cell: diam fluctuates 30% from base to end
*** PT cell: diam decreases monotonically by 54%

* [2019-10-28 Mon] - sfn comments
** Nicolangelo Iannella:
*** has a review on stochastic resonance in model neurons, would be interesting to look into
**** correlation coefficient of spiking output to input vs. noise level
**** spike number vs noise level for periodic input
**** signal to noise ratio vs noise level
**** TODO: more thorough read
*** suggested Narayanan & Johnston
**** super similar to what I'm doing
**** heavy emphasis on phase effects
**** TODO: also warrants a close reading 
** Ted Carnevale:
*** terms are wrong: local impedance -> input impedance, transfer to soma -> transfer between input and soma
*** needs to be lower amplitude signal
*** try using neuron's impedance class
**** [[https://www.neuron.yale.edu/phpBB/viewtopic.php?t=2745][impedance tool tutorial]]
**** having a quick go of it at 0.01 pA
*** difference in relationship between peak impedance and distance from soma in two models may have to do with differences in extent of apical tufts
** John Rinzel:
*** super bothered I couldn't rattle of elctrotonic length
** can't remember:
*** someone asked about gain, suggested making Bode plots
*** somone pointed out that Q value should increase with HCN densitiy, which doesn't really jive with pt cell results

* [2019-10-30 Wed]
** running both models up to 50 Hz, lower amplitude
** found a couple more relevant papers and very relevant masters thesis. again, need to read all more thoroughly 

* [2019-10-31 Thu] - trying noise insead of chirp
** higher frequency looks sensible for eee cell, gotta work out PT cell
** trying gaussian white noise rather than chirp - may be interesting to compare the two with impedance toolbox methods
*** replicating method from cook paper, 15 runs, 2 minutes each

* [2019-11-1 Fri]
** 2 min of noise still running, takes a long time, but so far looks good

* [2019-11-4 Mon]
** plotting results from 15 noise runs:
*** 
from scipy.io import loadmat
import numpy as np
from os import listdir
from os.path import isFile, join
datafiles = [f for f in listdir('./mat') if isfile(join('./mat/', f))]
for count, file in enumerate(datafiles):
    data = loadmat('./mat/'+file)
    if count == 0:
        zap_mat = np.zeros((15,len(data['zap_cis'][0])))
    zap_mat[count,:] = data['zap_cis'][0]
avg = np.mean(zap_mat,0)
err = np.std(zap_mat,0)
from matplotlib import pyplot as plt
plt.switch_backend('agg')
freq = np.linspace(0.5,50,zap_mat.shape[1])
plt.errorbar(freq, avg, yerr=err)
plt.xlabel('Frequency (Hz)')
plt.ylabel('Impedance (MOhm)')
plt.title('N = 15 Trials')
plt.savefig('/u/craig/EEE_network/eee_single/noiseResData/avgImpedanceExamp.png')
*** FIGURE: [[/u/craig/EEE_network/eee_single/noiseResData/avgImpedanceExamp.png][very...noisy, probably not enough smoothing on individual trial basis]]
** playing around with slew rate, smoothing window size

* [2019-11-11 Mon] - ironing out zap issues
** code for zap calculation:
def getzap (npin,npout,delay,sampr,bwinsz=50):
  from pylab import fft, convolve
  npin = npin[delay*sampr+1:-delay*sampr]
  npout = npout[delay*sampr+1:-delay*sampr]
  npin = npin - np.mean(npin)
  npout = npout - np.mean(npout)
  npin = np.hstack((np.zeros(delay*sampr),npin, np.zeros(delay*sampr)))
  npout = np.hstack((np.zeros(delay*sampr), npout, np.zeros(delay*sampr)))
  fmagin = abs(fft(npin)/len(npin))[0:int(len(npin)/2)]
  fmagout = abs(fft(npout)/len(npout))[0:int(len(npout)/2)]
  zap = fmagout / fmagin
  Freq = np.linspace(0.0, sampr/2.0, len(fmagout))
  fblur=np.array([1.0/bwinsz for i in range(bwinsz)])
  zapb=convolve(zap,fblur,'same')
  return Freq, fmagin, fmagout, zap, zapb

  * [2019-11-15 Fri]
  ** new code for zap calculation:
  def getzap (npin,npout,delay,sampr,bwinsz=1):
    from pylab import fft, convolve
    npin = npin[int(delay*sampr - 0.5*sampr+1):-int(delay*sampr- 0.5*sampr)]
    npout = npout[int(delay*sampr - 0.5*sampr)+1:-int(delay*sampr - 0.5*sampr)]
    npin = np.hstack((np.repeat(npin[0],int(delay*sampr)),npin, np.repeat(npin[-1], int(delay*sampr))))
    npout = np.hstack((np.repeat(npout[0],int(delay*sampr)), npout, np.repeat(npout[-1], int(delay*sampr))))
    npin = npin - np.mean(npin)
    npout = npout - np.mean(npout)
    fmagin = abs(fft(npin)/len(npin))[0:int(len(npin)/2)]
    fmagout = abs(fft(npout)/len(npout))[0:int(len(npout)/2)]
    zap = fmagout / fmagin
    Freq = np.linspace(0.0, sampr/2.0, len(fmagout))
    fblur=np.array([1.0/bwinsz for i in range(bwinsz)])
    zapb=convolve(zap,fblur,'same')
    return Freq, fmagin, fmagout, zap, zapb

* [2019-12-1 Sun] - redoing figures from poster with ted's suggestionsz

* [2019-12-2 Mon]
** Meeting w/ Bill 
*** writing up resonance
**** input impedance along trunk
**** what's going on at nexus and in apical tufts
**** nonlinear na thing 
*** working on RxD and Alzheimer's project
**** [[https://docs.google.com/document/d/14Y79JUJG5LHZGKgQLef9RGfXgdB29JJK_GTxhZ0sVLE/edit][AD & RxD grant proposal]]
*** deep learning
**** might be incorporated in above
** nexus stuff
*** plotting syns code:
from netpyne import sim, specs
from netParams_cell1 import netParams
from cfg_cell1 import cfg 
sim.create(netParams, cfg)
sim.analysis.plotShape(showSyns=True, synSiz=10)
**** syns specified by cfg
*** SCRIPT: [[./aroundNexus.py][script for measuring beyond multiple branchpoints in apical tufts]]
****  stimulate each and record from  rest:
sec_list = [pt_cell.apic[22],
            pt_cell.apic[23],
            pt_cell.apic[24],
            pt_cell.apic[25],
            pt_cell.apic[27],
            pt_cell.apic[28],
            pt_cell.apic[28],
            pt_cell.apic[31]]

* [2019-12-3 Tue] - transfer impedance in and around tufts
** banch points and nexus stuff
*** FOLDER: [[./nexus_data/][PTcell nexus data]]
*** FOLDER: [[../EEE_network/eee_single/nexus_data/][EEE cell nexus data]]
*** running examples from farthest section in both cells: distance or branch points?
**** code for finding distance to different secs. soma variables really just farthest parent sec
loc_num = loc
norm3d = np.linspace(0,1,sec.n3d())
ind3d = np.argmin((norm3d - loc_num)**2)
arc_loc = sec.arc3d(ind3d)
total_arc = arc_loc
parent_seg = sec.trueparentseg().sec
parent_seg_name = str(parent_seg)
while parent_seg_name != str(recordSec):
    # print(parent_seg_name)
    new_sec = parent_seg
    total_arc = total_arc + new_sec.arc3d(new_sec.n3d()-1)
    parent_seg = new_sec.trueparentseg().sec
    parent_seg_name = str(parent_seg)
soma3d = np.linspace(0,1,parent_seg.n3d())
indsoma = np.argmin((soma3d - 0.5) **2)
total_arc = total_arc + (parent_seg.arc3d(parent_seg.n3d()-1) - parent_seg.arc3d(indsoma))
*** FIGURE: [[./norm_imped_across_branch_points.png][between data points is branch point, normalized transfer impedance vs. distance]]

* [2019-12-4 Wed] - more transfer impedance in and around tufts
** calaculting transfer impedance in all segments
*** SCRIPT: [[./recordFromAll.py][PT cell, transfer impedance from a couple examples to all other segments]]
**** OUTPUT FOLDER: /u/craig/M1_Res/recordFromAll_data/
**** as of 5:30, hasn't gotten through one
**** DONE: check if same issue as below when one finished
*** SCRIPT: [[../EEE_network/eee_single/recordFromAll.py][EEE cell, transfer impedance from a couple examples to all other segments]]
**** OUTPUT FOLDER: /u/craig/EEE_network/eee_single/recordFromAll_data/
**** output somehow too large ... when loading cell prints 475 total segments; output lists have 482 entries
**** WTF???
** read chapter 3, linear cable theory, from Jack, Noble, Tsien 
*** what is meaning of electrotonic distance, lambda, if radius isn't constant?

* [2019-12-5 Thu]
** Chapter 4 - Jack, Noble, Tsien
*** Short Circuit: "Might apply to certain nerve cell geometries; for example, where a single dendritic trunk terminates centrally in a large soma
or where peripheral branching in a denritic tree is so profuse that it can be trated as a very low impedance beyond the branching point"
** reocrding transfer at all segments
*** difference in number of segs when using *sec.allseg()* vs *linspace(...)* methods becuase *sec.allseg()* returns locs [0,0.5,1.0] when nseg = 1
*** trying to get the right order for *cvals* for EEE cell
cvals = []
for sec in PYRcell.apical:
    for seg in sec.allseg():
        ind = 0
        while data['dend_names'][ind] != str(seg):
            ind = ind + 1
        cvals.append(data['transferImped'][ind])
cvals = cvals.reverse()
for sec in PYRcell.basal:
    for seg in sec.allseg():
        ind = 0
        while data['dend_names'][ind] != str(seg):
            ind = ind + 1
        cvals.append(data['transferImped'][ind])
cvals.extend(data['transferImped'][0:12])
**** this doesn't seem to work
*** same for PT cell
*** switching to neuron's PlotShape
from neuron import h 
from matplotlib import pyplot as plt
from matplotlib import cm
count = 0
for sec in h.allsec():
    for seg in sec.allseg():
        seg.v = data['transferImped'][count]
        count = count + 1
ps = h.PlotShape(pt_cell.apical_maintrunk, False)
ps.variable('v')
ps.plot(plt,cmap=cm.rainbow)
plt.savefig('/u/craig/M1_Res/transferShapePlotFigs/test1.png')

* [2019-12-6 Fri] - stil working out plotting transfer impedance / shape plots
** again, allsec() and length of say weightNorm don't match, shitty work around to do plotShape and cvar = 'weightNorm'
*** PT cell
from netParams_cell1 import netParams 
from cfg_cell1 import cfg 
from netpyne import sim, specs
import json 

sim.create(netParams, cfg)

with open('/home/craig/Documents/Neurosim_Lab/dendritic_resonance/recordFromAll_data/PTcell[0].dend[46]v2.json','r') as fileObj:            
    data = json.load(fileObj)

count = 0
cvals = []
for secName, sec in sim.net.cells[0].secs.items():
    print(secName)
    if sec['geom']['nseg'] != 1:
        for i in range(sec['geom']['nseg']):
            # sim.net.cells[0].secs[secName]['weightNorm'][i] = data['transferImped'][count]
            # if data['transferImped'][count] < 90:
            if secName != 'dend_46':
                cvals.append(data['transferImped'][count])
            # else:
            #     cvals.append(0)
            else:
                cvals.append(0)
            print(data['dend_names'][count])
            count = count + 1
        count = count + 2
    else:
        count = count + 1
        # sim.net.cells[0].secs[secName]['weightNorm'][0] = data['transferImped'][count]
        # if data['transferImped'][count] > 20:
        cvals.append(data['transferImped'][count])
        # else:
        #     cvals.append(20)
        print(data['dend_names'][count])
        count = count + 2

# sim.analysis.plotShape(cvar='weightNorm', includeAxon=False, showSyns=True, synSiz = 10)
sim.analysis.plotShape(cvals=cvals, includeAxon=True, showSyns=True, synSiz = 10)

*** EEE cell
from netParams import netParams
from cfg import cfg
from netpyne import sim, specs
import json 

sim.create(netParams, cfg)

with open('/home/craig/Documents/Neurosim_Lab/dendritic_resonance/recordFromAll_data_EEE/basal[8]v2.json','r') as fileObj:            
    data = json.load(fileObj)

count = 0
cvals = []
for secName, sec in sim.net.cells[0].secs.items():
    print(secName)
    if sec['geom']['nseg'] != 1:
        for i in range(sec['geom']['nseg']):
            # sim.net.cells[0].secs[secName]['weightNorm'][i] = data['transferImped'][count]
            # if data['transferImped'][count] < 90:
            if secName != 'basal_8':
                cvals.append(data['transferImped'][count])
            # else:
            #     cvals.append(0)
            else:
                cvals.append(0)
            print(data['dend_names'][count])
            count = count + 1
        count = count + 2
    else:
        count = count + 1
        # sim.net.cells[0].secs[secName]['weightNorm'][0] = data['transferImped'][count]
        # if data['transferImped'][count] > 20:
        cvals.append(data['transferImped'][count])
        # else:
        #     cvals.append(20)
        print(data['dend_names'][count])
        count = count + 2

sim.analysis.plotShape(cvals=cvals, includeAxon=True, showSyns=True, synSiz = 10)

** calculating distance between two points - tailored for EEE
*** still have some kinks to iron out, but seems to almost be there
#------------------------------------------------------------------------------
# calculate path length between two sections
def pathLength(sec1, loc1, sec2, loc2, soma_sec):
    # find lineage of first section
    loc_num = loc1
    norm3d = np.linspace(0,1,sec1.n3d())
    ind3d = np.argmin((norm3d - loc_num)**2)
    arc_loc = sec1.arc3d(ind3d)
    total_arc = arc_loc
    lineage1 = [sec1(loc1)]
    parent_seg = sec1.trueparentseg().sec
    parent_seg_name = parent_seg.name()[:4]
    lineage1.append(parent_seg)
    while parent_seg != soma_sec:
        # print(parent_seg_name)
        next_sec = parent_seg
        total_arc = total_arc + next_sec.arc3d(next_sec.n3d()-1)
        parent_seg = next_sec.trueparentseg().sec
        parent_seg_name = parent_seg.name()[:4]
        lineage1.append(parent_seg)

    # find lineage of second section
    loc_num = loc2
    norm3d = np.linspace(0,1,sec2.n3d())
    ind3d = np.argmin((norm3d - loc_num)**2)
    arc_loc = sec2.arc3d(ind3d)
    total_arc = arc_loc
    lineage2 = [sec2(loc2)]
    if str(type(sec2.trueparentseg())).split("'")[1] != 'NoneType':
        parent_seg = sec2.trueparentseg().sec
        parent_seg_name = parent_seg.name()[:4]
        lineage2.append(parent_seg)
        while parent_seg != soma_sec:
            # print(parent_seg_name)
            next_sec = parent_seg
            total_arc = total_arc + next_sec.arc3d(next_sec.n3d()-1)
            parent_seg = next_sec.trueparentseg().sec
            parent_seg_name = parent_seg.name()[:4]
            lineage2.append(parent_seg)
    else:
        lineage2 = [sec2]

    # find common ancestor
    same = 0
    ind = 0
    while same == 0:
        for sec in lineage2:
            if lineage1[ind] == sec:
                same = sec
        ind = ind + 1

    # find distances to common ancestor
    loc_num = loc1
    norm3d = np.linspace(0,1,sec1.n3d())
    ind3d = np.argmin((norm3d - loc_num)**2)
    arc_loc = sec1.arc3d(ind3d)
    total_arc1 = arc_loc
    parent_seg = sec1.trueparentseg().sec
    while parent_seg != same:
        # print(parent_seg_name)
        next_sec = parent_seg
        total_arc1 = total_arc1 + next_sec.arc3d(next_sec.n3d()-1)
        parent_seg = next_sec.trueparentseg().sec

    loc_num = loc2
    norm3d = np.linspace(0,1,sec2.n3d())
    ind3d = np.argmin((norm3d - loc_num)**2)
    arc_loc = sec2.arc3d(ind3d)
    total_arc2 = arc_loc
    if str(type(sec2.trueparentseg())).split("'")[1] != 'NoneType':
        parent_seg = sec2.trueparentseg().sec
        while parent_seg != same:
            # print(parent_seg_name)
            next_sec = parent_seg
            total_arc2 = total_arc2 + next_sec.arc3d(next_sec.n3d()-1)
            parent_seg = next_sec.trueparentseg().sec
    else:
        total_arc2 = 0

    path_length = total_arc1 + total_arc2

    return path_length
* [2019-12-7 Sat] - more on transfer imped in apical dends
** above function for distance between two locations works for both (have to exclude axon from pt_cell)
*** plot tranfer impedance vs path length for a few stim locations:
**** EEE cell
# define pathLength from above
from matplotlib import pyplot as plt
from os import listdir
from os.path import isfile, join
import json
import numpy as np
from scipy.io import savemat
from neuron import h, gui 

def fromtodistance(origin_segment, to_segment):
    h.distance(0, origin_segment.x, sec=origin_segment.sec)
    return h.distance(to_segment.x, sec=to_segment.sec)

exec(open('../cells/eeeD.py').read())
PYRcell = MakeCell()

# base_path = '/home/craig/Documents/Neurosim_Lab/dendritic_resonance/recordFromAll_data_EEE/'
base_path = '/u/craig/EEE_network/eee_single/recordFromAll_data/'
datafiles = [f for f in listdir(base_path) if isfile(join(base_path, f))]

# secs = [PYRcell.apical[9],
#         PYRcell.apical[13],
#         PYRcell.apical[34],
#         PYRcell.apical[10],
#         PYRcell.basal[8],
#         PYRcell.apical[8]]

secs = []
for file in datafiles:
    if file.split('.')[1][0] == 'b':
        secs.append(PYRcell.basal[int(file.split('.')[1].split('[')[1].split(']')[0])])
    else:
        secs.append(PYRcell.apical[int(file.split('.')[1].split('[')[1].split(']')[0])])
soma_sec = PYRcell.soma[0]
sec_names = []
sec_inds = []

above_inds = [i for i in range(8,33)]

leg_list = []
for ind, filename in enumerate(datafiles):
    with open(base_path+filename,'r') as fileObj:
        data = json.load(fileObj)

    sec = secs[ind]
    leg_list.append(sec.name())
    path_lengths = []
    isAfterBranchPoint = []
    for item in h.allsec():
        is_abp = 0
        for above_ind in above_inds:
            if item == PYRcell.apical[above_ind]:
                is_abp = 1

        for seg in item.allseg():
            sec_names.append(str(seg))
            # if seg != sec(0.5):
                # dist = pathLength(sec, 0.5, item, float(str(seg).split('(')[1].split(')')[0]), soma_sec)
            dist = fromtodistance(sec(0.5),item(float(str(seg).split('(')[1].split(')')[0])))
            # else:
            #     dist = 0
            path_lengths.append(dist)
            isAfterBranchPoint.append(is_abp)

    out = {'path_lengths' : path_lengths,
            'transferImped' : data['transferImped'],
            'transferResFreq' : data['transferResFreq'],
            'isAfterBranchPoint' : isAfterBranchPoint}

    savemat(base_path+'/mat/'+filename[:-4]+'mat', out)


#     plt.figure()
#     # plt.scatter(path_lengths, data['transferImped'])
#     plt.scatter(path_lengths, data['transferResFreq'])
#     plt.xlabel('Distance (microns)')
#     plt.ylabel('Impedance (MOhms)')
#     plt.title(sec.name())

# plt.show()
**** PT cell
# from matplotlib import pyplot as plt
from os import listdir
from os.path import isfile, join
import json
import numpy as np
from neuron import h, gui
from cfg_cell1 import cfg 
from scipy.io import savemat

def fromtodistance(origin_segment, to_segment):
    h.distance(0, origin_segment.x, sec=origin_segment.sec)
    return h.distance(to_segment.x, sec=to_segment.sec)

h.load_file("./cells/PTcell.hoc")
#Create a PT cell             
ihMod2str = {'harnett': 1, 'kole': 2, 'migliore': 3} #which model . . . look this up
pt_cell = h.PTcell(ihMod2str[cfg.ihModel], cfg.ihSlope)

# base_path = '/home/craig/Documents/Neurosim_Lab/dendritic_resonance/recordFromAll_data_PT/'
base_path = '/u/craig/M1_Res/recordFromAll_data/'
datafiles = [f for f in listdir(base_path) if isfile(join(base_path, f))]

secs = []
for file in datafiles:
    if file.split('.')[1][0] == 'd':
        secs.append(pt_cell.dend[int(file.split('.')[1].split('[')[1].split(']')[0])])
    else:
        secs.append(pt_cell.apic[int(file.split('.')[1].split('[')[1].split(']')[0])])
# secs = [pt_cell.apic[22],
#         pt_cell.apic[23],
#         pt_cell.dend[46],
#         pt_cell.apic[88],
#         pt_cell.apic[31],
#         pt_cell.apic[29],
#         pt_cell.apic[24],
#         pt_cell.apic[25],
#         pt_cell.apic[27]]

abp_list = []
for sec in pt_cell.apical_afterbranchpoint:
    for seg in sec.allseg():
        abp_list.append(str(seg))
basal_list = []
for sec in pt_cell.basal:
    for seg in sec.allseg():
        basal_list.append(str(seg))

soma_sec = pt_cell.soma


leg_list = []
for ind, filename in enumerate(datafiles):
    with open(base_path+filename,'r') as fileObj:
        data = json.load(fileObj)
    
    transImped = [data['transferImped'][i] for i in range(len(data['transferImped'])) if data['dend_names'][i][11] != 'x']
    freqAtten = [data['transferResFreq'][i] for i in range(len(data['transferResFreq'])) if data['dend_names'][i][11] != 'x']
    sec = secs[ind]
    sec_names = []
    leg_list.append(sec.name())
    path_lengths = []
    isAfterBranchPoint = []
    isBasal = []
    for item in h.allsec():
        if item != pt_cell.axon:
            for seg in item.allseg():
                sec_names.append(str(seg))
                # if seg != sec(0.5):
                    # dist = pathLength(sec, 0.5, item, float(str(seg).split('(')[1].split(')')[0]), soma_sec)
                    # dist = h.distance(sec(0.5), item(float(str(seg).split('(')[1].split(')')[0])))
                dist = fromtodistance(sec(0.5), item(float(str(seg).split('(')[1].split(')')[0])))
                # else:
                #     dist = 0
                path_lengths.append(dist)

                is_abp = 0
                for name in abp_list:
                    if str(seg) == name:
                        is_abp = 1
                isAfterBranchPoint.append(is_abp)

                is_basal = 0
                for name in basal_list:
                    if str(seg) == name:
                        is_basal = 1
                isBasal.append(is_basal)

    out = {'path_lengths' : path_lengths,
            'transferImped' : transImped,
            'transferResFreq' : freqAtten,
            'sec_names' : sec_names,
            'isAfterBranchPoint' : isAfterBranchPoint,
            'isBasal' : isBasal}
    savemat(base_path+'/mat/'+filename[:-4]+'mat', out)
    # plt.figure()
    # # plt.scatter(path_lengths, transImped)
    # plt.scatter(path_lengths, freqAtten)
    # plt.xlabel('Distance (microns)')
    # plt.ylabel('Impedance (MOhms)')
    # plt.title(sec.name())
# plt.legend(leg_list)

# plt.show()

* [2019-12-8 Sun] - how to display this . . .
** matlab code for plotting data, seems like a decent visualization
*** PT
cmap = colormap('jet');
path = '/home/craig/Documents/Neurosim_Lab/dendritic_resonance/recordFromAll_data_PT/mat/';
l = dir(path);
fig_count = 1;
for i = 1:length(l)
    if ~l(i).isdir
        load(strcat(path,l(i).name))
        inds = floor(((transferResFreq-min(transferResFreq)))/(max(transferResFreq)-min(transferResFreq))*63)+1;
        a_count = 1;
        n_count = 1;
        figure(fig_count);
        hold on
        for j = 1:length(transferResFreq)
            if isAfterBranchPoint(j) && a_count == 1
                p1 = plot(path_lengths(j), transferImped(j), 'o', 'Color', cmap(inds(j),:), 'LineWidth', 2);
                a_count = 2;
            elseif isAfterBranchPoint(j)
                plot(path_lengths(j), transferImped(j), 'o', 'Color', cmap(inds(j),:), 'LineWidth', 2)
            elseif n_count == 1
                p2 = plot(path_lengths(j), transferImped(j), '+', 'Color', cmap(inds(j),:), 'LineWidth', 2);
                n_count = 2;
            else
                plot(path_lengths(j), transferImped(j), '+', 'Color', cmap(inds(j),:), 'LineWidth', 2)
            end
        end
        lims = ylim();
        ylim([0, lims(2)])
        colormap('jet')
        colorbar
        caxis([min(transferResFreq), max(transferResFreq)])
        title(l(i).name(1:end-6))
        xlabel('Distance (\mum)')
        ylabel('Transfer Impedance (M\Omega)')
        legend([p2,p1], {'Before Nexus', 'After Nexus'})
        fig_count = fig_count + 1;
        keep cmap path path2 l fig_count
        # figure(fig_count + 1);
        # hold on
        # for j = 1:length(transferResFreq)
        #     if isBasal(j)
        #         plot(path_lengths(j), transferImped(j), '+', 'Color', cmap(inds(j),:), 'LineWidth', 2)
        #     end
        # end
        # colormap('jet')
        # colorbar
        # caxis([min(transferResFreq), max(transferResFreq)])
        # title(l(i).name(1:end-6))
        # xlabel('Distance (\mum)')
        # ylabel('Transfer Impedance (M\Omega)')
        
        # fig_count = fig_count + 2;
    end
end

* [2019-12-9 Mon] - fancy figures and some attempts at interpretations 
** more matlab plotting
*** EEE
cmap = colormap('jet');
path = '/home/craig/Documents/Neurosim_Lab/dendritic_resonance/recordFromAll_data_EEE/mat/';
l = dir(path);
for i = 1:length(l)
    if ~l(i).isdir
        load(strcat(path,l(i).name))
        inds = floor(((transferResFreq-min(transferResFreq)))/(max(transferResFreq)-min(transferResFreq))*63)+1;
        figure();
        hold on
        a_count = 1;
        n_count = 1;
        for j = 1:length(transferResFreq)
            if isAfterBranchPoint(j) && a_count == 1
                p1 = plot(path_lengths(j), transferImped(j), 'o', 'Color', cmap(inds(j),:), 'LineWidth', 2);
                a_count = 2;
            elseif isAfterBranchPoint(j)
                plot(path_lengths(j), transferImped(j), 'o', 'Color', cmap(inds(j),:), 'LineWidth', 2)
            elseif n_count == 1
                p2 = plot(path_lengths(j), transferImped(j), '+', 'Color', cmap(inds(j),:), 'LineWidth', 2);
                n_count = 2;
            else
                plot(path_lengths(j), transferImped(j), '+', 'Color', cmap(inds(j),:), 'LineWidth', 2)
            end
        end
        lims = ylim();
        ylim([0, lims(2)])
        colormap('jet')
        colorbar
        caxis([min(transferResFreq), max(transferResFreq)])
        title(l(i).name(1:end-6))
        xlabel('Distance (\mum)')
        ylabel('Transfer Impedance (M\Omega)')
        legend([p2,p1], {'Below Nexus', 'Above Nexus'})
    end
end

** FIGURES: [[https://drive.google.com/open?id=1cQbyHxPqROjESmfNusyoSwGZ4HY9bs75XU73hUtks40][Google slides with figs]]
** Interpretations:
*** Tendency for impedance to go to zero in PT cell implies structures near/beyond nexus have short circuit-like behavior because of profuse branching
**** beyond nexus, computations must be highly local, but have greater variation in peak frequency
*** Sufficiently far below nexus, branches have more open circuit-like behavior (see Jack, Noble, Tsien)
*** In EEE cell, all branches show open circuit - like behavior
**** probably explained by less branching complexity beyond nexus compared to PT
**** since basically end to end voltage transfer, EEE cell capable of global computations
***** test by arbitrarily growing branches?
*** In both cell models, most of basal arbor sees very similar transfer impedance at very close resonant frequencies
*** peak frequency of the transfer impedance at any given section depends on the location of stimulation / peak frequency for the input impedance

* [2019-12-12 Thu]
** a lot of above trickled into [2019-12-9 Mon], meetings [2019-12-10 Tue] (suggested to look at PT5B cell from Hay et al. 2011), [2019-12-11 Wed] responding to Ted:
*** ted's questions
> The main results are that in the mouse cell, there is little to no
> current flow from the apical tufts to the basal dends / soma or vice
> versa (so, only local computations), while in the rat (EEE) model the
> whole arbor is electrically "available" from any other point on the
> arbor (global computations).

Interesting conjecture. I doubt it, but it's worth thinking about.
Stated in plain english, you mean to suggest that rat neurons are
functionally equivalent to single compartments, but mouse neurons can be
regarded as complex assemblies of integrative units. Bart Mel has
similar ideas about local processing in pyramidal neurons of rats. But
if you're right, mice could be smarter than rats, if not the most
intelligent species on Earth after all.

The figures by themselves don't prove the conjecture. But first,

1. How do the anatomical properties of the model mouse and rat neurons
differ? For any of the model cells that were used to generate these
figures, how does diameter vary as a function of path distance from the
soma?


2. How do the specifications of the biophysical properties of model
mouse neurons and rat neurons differ? Would completely passive model
cells lead you to the same conclusion about "local" vs. "global" signal
spread?


3. How was spatial discretization implemented in these models?


Now to the figures--

How was each figure generated, and what is it supposed to convey to the
viewer? Without explanation, they don't tell a story.

In the plots that address input impedance, exactly where was the
measurement made?

In those that address transfer impedance (Zx hereafter), what are the
two points between which Zx was calculated?


What is the term "nexus" supposed to mean?

In most cases, the "resonance" is not very impressive. Does it even
matter? I think you'll find that the degree of local vs. global
processing in the subthreshold range of membrane potential is governed
primarily by cm, Ra, diameter, length, and branching pattern, and has
very little to do with active membrane properties.


The figures with all the o's and +'s are particularly puzzling and need
a clear, concise description of how they were generated, what is being
shown, and what they are supposed to tell the viewer.


The rainbow scales are colorful but a distraction. What is being
plotted--values calculated at 3 or 4 different frequencies? How were
those frequencies chosen? Having selected 3 or 4 frequencies, why not
pick 3 or 4 different colors, provide a legend that associates a
particular color with a particular frequency, and be done with it?



Where does Figure 15 come from, and what is it supposed to show the viewer?


Which figures provide information about current flow?


Which figures provide a basis for comparison of signaling in mouse
neurons and rat neurons?


--Ted
*** response
Hi Ted,

Thanks for your questions/comments.  Hopefully I address most of them below.

>  Stated in plain english, you mean to suggest that rat neurons are
>  functionally equivalent to single compartments, but mouse neurons can be
>  regarded as complex assemblies of integrative units.
That's the idea, but I'd constrain it to these models rather than mouse/rat cells in general.

>  1. How do the anatomical properties of the model mouse and rat neurons
>  differ? For any of the model cells that were used to generate these
>  figures, how does diameter vary as a function of path distance from the
>  soma?
>  2. How do the specifications of the biophysical properties of model
>  mouse neurons and rat neurons differ? Would completely passive model
>  cells lead you to the same conclusion about "local" vs. "global" signal
>  spread? . . .  I think you'll find that the degree of local vs. global
>  processing in the subthreshold range of membrane potential is governed
>  primarily by cm, Ra, diameter, length, and branching pattern, and has
>  very little to do with active membrane properties.
I've added plots of diameter, Ra, cm, and input resistance to the Google Doc.  Diameters vs distance from the soma are very similar between the two, and there are differences in rm, cm, and ri, but nothing really jumps out as obviously explaining the differences between the two. 

>  3. How was spatial discretization implemented in these models? 
â€‹I'm not sure about this one.  Will have to check and get back to you.

>  In the plots that address input impedance, exactly where was the
>  measurement made?
For the plots with the black traces, I've added in shape plots with red dots indicating the location for stimulation.  Input impedance was measured from the same segment/location as stimulation. These are pretty much just example figures, just showing that the peak impedance and frequency changes depending on where you stimulate.

>  The figures with all the o's and +'s are particularly puzzling and need
>  a clear, concise description of how they were generated, what is being
>  shown, and what they are supposed to tell the viewer.
>
>
>  The rainbow scales are colorful but a distraction. What is being
>  plotted--values calculated at 3 or 4 different frequencies? How were
>  those frequencies chosen? Having selected 3 or 4 frequencies, why not
>  pick 3 or 4 different colors, provide a legend that associates a
>  particular color with a particular frequency, and be done with it?
These figures show the maximal transfer impedance between the stimulation site and all other segments from a chirp current stimulus, and the coloring indicates the frequency of maximal transfer impedance.  I've added in shape plots with the exact stimulation locations labelled.  These are the figures that would address current flow and global vs. local subthreshold computation or signalling.

>  In most cases, the "resonance" is not very impressive. Does it even
>  matter? 
>  The rainbow scales are colorful but a distraction. What is being
>  plotted--values calculated at 3 or 4 different frequencies? How were
>  those frequencies chosen? Having selected 3 or 4 frequencies, why not
>  pick 3 or 4 different colors, provide a legend that associates a
>  particular color with a particular frequency, and be done with it?
I agree that resonance (maybe maximal reactivity is a better phrase) is not very strong, but I think it matters because impedance (input or transfer) clearly still has frequency dependence.   For instance, if I stimulate a tuft at an arbitrary frequency and measure a low transfer impedance between there and the soma, who's to say that it wouldn't be higher at some other frequency? 

>  What is the term "nexus" supposed to mean?
â€‹The nexus refers to the branch point at the end of the apical main trunk where  you start getting more extensive branching up towards the tufts.

>  Where does Figure 15 come from, and what is it supposed to show the viewer?
â€‹That's from Jack, Noble, and Tsien's Electric Current Flow in Excitable Cells, and shows the differences between branches with (what they describe as) open and short circuit behavior.   I was originally fairly confused by that, and Bill wasn't very keen on the nomenclature, but it seems that branches near or beyond the nexus have more of this short-circuit behavior than the open circuit-like behavior in the basal dendrites and across the arbor in the rat cell model.  It wasn't really included for the benefit of the viewer so much as to explain myself in lab meeting yesterday.  

Best,
Craig

** trying to get cells from Hay et al working  - running 

* [2019-12-13 Fri] 
** answering ted's questions:
>> â€‹ The nexus refers to the branch point at the end of the apical main
>> trunk where  you start getting more extensive branching up towards the
>> tufts.
>If this is a standard term in neuroscience with an accepted
>definition, please send me a citation.  If it isn't, where
>did it come from?
This is a standard term.  I can't find an original definition, but here are a couple papers that use it:
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3847879/
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4300316/

>Why is the cell in slide 10 not the same as the cell in 9, 11, and 12?
>Where are the plots of v vs. t, Zin, and Zx between the apical oblique
>and the soma for the cell that is used in slides 9, 11, and 12?
These are actually the same cell. I just rotated it in that figure so you could see the red dot.

>>These are the figures that would address current flow and
>> global vs. local subthreshold computation or signalling.
>How do they accomplish that?
OK, I follow your explanation about how this doesn't reflect current flow. I should say voltage transfer. Transfer impedance would be the limiting factor in the spread of subthreshold
fluctuations in membrane potential, and that would effect the local/globalness of computations, right?

>Ra is the hardest parameter to estimate accurately; what is
>the rationale for specifying the mouse value to more than
>1.5 significant figures?
>
>What is the empirical basis for assigning:
>
>rat Ra = 90 ohm cm and mouse Ra 137.x?
>
>different values to Rat cm (almost 2.2 uf/cm2)
>and mouse cm (<= about 1.05 uf/cm2)?
>
>so many different values to cm in mouse obliques?
In the original papers, they state what the passive parameters are but don't provide much justification for why they were chose.
Both used a "spiny factor" to account for increased cm and leak conductance in spiny cells. However, in the mouse model the cm's I have plotted don't seeem to
match what was stated in the paper, so I have to go back and double check that.


>In figure 17 note that for rat many diameter measurements lie
>between about 0.25 and 0.5 um.  However, the smallest diameters
>for the mouse neuron are 0.5 um.  Look at the clouds of data
>points and note that in the rat the diameters appear to get
>progressively smaller with increasing distance from the soma,
>but that in mouse they just hit a hard limit at 0.5 um.  Does
>this seem reasonable, or does it suggest a systematic bias
>in the mouse measurements?
I hadn't noticed that, but yes, that would point a bias in the measurements for the mouse cell.

>Do these morphometric data even come from the same lab?
No, the mouse cell comes from Gordon Shepherd and the rat from Srdjan Antic. 

>The bias would be revealed more clearly if these plots included
>lines that connected each parent point to its child point(s).
OK, I can try to put that together.

>Summing up, the mouse morphometric data probably overestimate
>the diameters of the fine basal and apical tuft branches.
>That will increase the load on the proximal end of the
>apical trunk for signals spreading toward the soma,
>and the load on the distal end of the apical trunk for
>signals spreading away from the soma.  The result will
>be to decrease transfer impedance between the basilar
>and apical dendrites from what it would be if the small
>diameter branches were measured accurately down to 0.25 um.

* [2020-1-3 Fri] - transfer impedance
** made corrections to distance calculation yesterday for colorful transfer impedance plots
** ran example transfer impedance runs on hay cell
*** code for plotting transfer impedances for hay cell
cmap = colormap('jet');
path = '/home/craig/Documents/Neurosim_Lab/dendritic_resonance/recordFromAll_data_hay/chirp_recordAll/basal/';
path2 = '/home/craig/Documents/Neurosim_Lab/dendritic_resonance/recordFromAll_data_hay/chirp_recordAll/apical/';
l = dir(path);
for i = 1:length(l)
    if ~l(i).isdir
        load(strcat(path,l(i).name))
        path_lengths_basal = path_lengths;
        transferImped_basal = transferImped;
        transferResFreq_basal = transferResFreq;
        load(strcat(path2, l(i).name(1:end-9), 'apical.mat'))
        isBasal = [zeros(1,length(transferImped)), ones(1,length(transferImped_basal))];
        transferImped = [transferImped, transferImped_basal];
        transferResFreq = [transferResFreq, transferResFreq_basal];
        path_lengths = [path_lengths, path_lengths_basal];
        inds = floor(((transferResFreq-min(transferResFreq)))/(max(transferResFreq)-min(transferResFreq))*63)+1;
        figure();
        hold on
        a_count = 1;
        n_count = 1;
        for j = 1:length(transferResFreq)
            if ~isBasal(j) && a_count == 1
                p1 = plot(path_lengths(j), transferImped(j), 'o', 'Color', cmap(inds(j),:), 'LineWidth', 2);
                a_count = 2;
            elseif ~isBasal(j)
                plot(path_lengths(j), transferImped(j), 'o', 'Color', cmap(inds(j),:), 'LineWidth', 2)
            elseif n_count == 1
                p2 = plot(path_lengths(j), transferImped(j), '+', 'Color', cmap(inds(j),:), 'LineWidth', 2);
                n_count = 2;
            else
                plot(path_lengths(j), transferImped(j), '+', 'Color', cmap(inds(j),:), 'LineWidth', 2)
            end
        end
        colormap('jet')
        colorbar
        caxis([min(transferResFreq), max(transferResFreq)])
        title(l(i).name(1:end-10))
        xlabel('Distance (\mum)')
        ylabel('Transfer Impedance (M\Omega)')
        legend([p1,p2], 'Apical', 'Basal')
    end
    keep cmap path path2 l
end
** very strange ... m1 cell, apic 31, 27, 29 transfer impedance looks like increases w/ distance ...
*** not in apic 25
*** has to do with huge frequency range I believe - probably goes away if just plotting transfer impedance for one frequency
** running Shepherd morphology with hay biophys 

* [2020-1-5 Sun] - reading papers
** Active membrane conductances and morphology of a collision detection neuron broaden its impedance profile and improve discrimination of input synchrony
X Richard B. Dewell1 and X Fabrizio Gabbiani1,2
1
Department of Neuroscience, Baylor College of Medicine, Houston, Texas; and 2
Department of Electrical and Computer
*** they look at transfer impedance between stim site and site of spike initiation
*** "To assess the relative electrotonic distances between recording locations we measured the amplitude of
the back-propagating action potentials (bAPs) from the resting membrane potential to its peak (Fig. 2E) at each location and used the
difference in these amplitudes. As in a previous study, the differences in bAP amplitude provided a more reliable explanatory variable for
distance-dependent effects (Dewell and Gabbiani 2018a)."
*** "We found that the neuronâ€™s morphology and the active conductances gH and gM (Fig. 5G) dramatically reduced frequency variation of the impedance gain,
making the LGMD membrane impedance more broadband. This was surprising, because both gH and gM usually make neurons more band pass (HÃ¶nigsperger et al. 2015; Hu et al.
2009; Hutcheon and Yarom 2000; Narayanan and Johnston 2008). The primary effect of gH on the membrane impedance (Fig. 5, B and C) is actually the same as in other neurons: a
reduction of low-pass filtering and impedance delay. Whether gH narrows the membrane band-pass properties or broadens them, as it does here and in CA3 interneurons (Anderson et al.
2011), depends on the relative balance of its effects and those of other membrane properties."
** Models of Neocortical Layer 5b Pyramidal Cells Capturing a Wide Range of Dendritic and Perisomatic Active Properties
Etay Hay 1 *, Sean Hill 2 , Felix SchÃ¼rmann 2 , Henry Markram 2 , Idan Segev 1,3
1 Interdisciplinary Center for Neural Computation and Edmond and Lily Safra Center for Brain Sciences, The Hebrew University, Jerusalem, Israel, 2 Brain Mind Institute,
Ecole Polytechnique FÃ¨dÃ¨rale de Lausanne (EPFL), Lausanne, Switzerland, 3 Department of Neurobiology, The Hebrew University, Jerusalem, Israel
*** 4 biophys constrained with current step firing, backpropagating action potential, and both
**** will try transfer imped on all four, same morph
*** poor model transfer between morphologies: "the difference in the dendritic load underlies the poor transfer
of parameters between the two modeled cells"

* [2020-1-6 Mon]
** meeting w/ sabina, going ahead w/ qual writeup as review, going to work on first draft, will send to her & bill 
** running both biophysics for hay model finished
*** biophys constrained by current step firing isn't comparable to M1 PT 

* [2020-1-7 Tue] - plotting, notes on impedance story
** put all biophys from hay on same fig
cmap = colormap('jet');
path_b1_basal = '/home/craig/Documents/Neurosim_Lab/dendritic_resonance/biophys1/Basal/';
path_b1_apical = '/home/craig/Documents/Neurosim_Lab/dendritic_resonance/biophys1/Apical/';
path_b2_basal = '/home/craig/Documents/Neurosim_Lab/dendritic_resonance/biophys2/Basal/';
path_b2_apical = '/home/craig/Documents/Neurosim_Lab/dendritic_resonance/biophys2/Apical/';
path_b3_basal = '/home/craig/Documents/Neurosim_Lab/dendritic_resonance/recordFromAll_data_hay/chirp_recordAll/basal/';
path_b3_apical = '/home/craig/Documents/Neurosim_Lab/dendritic_resonance/recordFromAll_data_hay/chirp_recordAll/apical/';
%i = 6;
l = dir(path_b1_basal);
for i = 1:length(l)
    if ~l(i).isdir
        load(strcat(path_b1_basal,l(i).name))
        path_lengths_basal = path_lengths;
        transferImped_basal = transferImped;
        transferResFreq_basal = transferResFreq;
        load(strcat(path_b1_apical, l(i).name(1:end-9), 'apical.mat'))
        isBasal = [zeros(1,length(transferImped)), ones(1,length(transferImped_basal))];
        transferImped_b1 = [transferImped, transferImped_basal];
        transferResFreq_b1 = [transferResFreq, transferResFreq_basal];
        path_lengths_b1 = [path_lengths, path_lengths_basal];

        load(strcat(path_b2_basal,l(i).name))
        path_lengths_basal = path_lengths;
        transferImped_basal = transferImped;
        transferResFreq_basal = transferResFreq;
        load(strcat(path_b2_apical, l(i).name(1:end-9), 'apical.mat'))
        isBasal = [zeros(1,length(transferImped)), ones(1,length(transferImped_basal))];
        transferImped_b2 = [transferImped, transferImped_basal];
        transferResFreq_b2 = [transferResFreq, transferResFreq_basal];
        path_lengths_b2 = [path_lengths, path_lengths_basal];

        load(strcat(path_b3_basal,l(i).name))
        path_lengths_basal = path_lengths;
        transferImped_basal = transferImped;
        transferResFreq_basal = transferResFreq;
        load(strcat(path_b3_apical, l(i).name(1:end-9), 'apical.mat'))
        isBasal = [zeros(1,length(transferImped)), ones(1,length(transferImped_basal))];
        transferImped_b3 = [transferImped, transferImped_basal];
        transferResFreq_b3 = [transferResFreq, transferResFreq_basal];
        path_lengths_b3 = [path_lengths, path_lengths_basal];

        transferResFreq = [transferResFreq_b1, transferResFreq_b2, transferResFreq_b3];
        inds = floor(((transferResFreq-min(transferResFreq)))/(max(transferResFreq)-min(transferResFreq))*63)+1;
        count = 1;
        figure('units','normalized','outerposition',[0 0 1 1]);
        subplot(1,3,1)
        hold on
        for j = 1:length(transferResFreq_b1)
            if j == 1
                p1 = plot(path_lengths_b1(j), transferImped_b1(j), '*', 'Color', cmap(inds(count),:), 'LineWidth', 2);
            else
                plot(path_lengths_b1(j), transferImped_b1(j), '*', 'Color', cmap(inds(count),:), 'LineWidth', 2);
            end
            count = count + 1;
        end
        xlabel('Distance (\mum)')
        ylabel('Transfer Impedance (M\Omega)')
        title('BAC Firing')

        subplot(1,3,2)
        hold on
        for j = 1:length(transferResFreq_b2)
            if j == 1
                p2 = plot(path_lengths_b2(j), transferImped_b2(j), '*', 'Color', cmap(inds(count),:), 'LineWidth', 2);
            else
                plot(path_lengths_b2(j), transferImped_b2(j), '*', 'Color', cmap(inds(count),:), 'LineWidth', 2);
            end
            count = count + 1;
        end
        xlabel('Distance (\mum)')
        ylabel('Transfer Impedance (M\Omega)')
        title('Current Step Firing')

        subplot(1,3,3)
        hold on
        for j = 1:length(transferResFreq_b3)
            if j == 1
                p3 = plot(path_lengths_b3(j), transferImped_b3(j), '*', 'Color', cmap(inds(count),:), 'LineWidth', 2);
            else
                plot(path_lengths_b3(j), transferImped_b3(j), '*', 'Color', cmap(inds(count),:), 'LineWidth', 2);
            end
            count = count + 1;
        end
        xlabel('Distance (\mum)')
        ylabel('Transfer Impedance (M\Omega)')
        title('BAC + Current Step *Firing')
        colormap('jet')
        colorbar
        caxis([min(transferResFreq), max(transferResFreq)])
        l(i).name
    end
    keep path_b1_basal path_b1_apical path_b2_basal path_b2_apical path_b3_basal path_b3_apical cmap i l
end
** plotted cm, cytoplasmic resistance, and Rin for all three hay biophys and practically no differences between them
** story for transfer resonance
*** PT cell from M1 model only one where transfer impedance goes to ~0
**** doesn't seem to be matter of morphology, because that morph with different biophys didn't do that, see examples below
***** [[./hay_neymotin_biophys_compare/apical22.png][apical trunk, below nexus/branchpoint]]
***** [[./hay_neymotin_biophys_compare/apical31.png][apical tuft, above nexus/branchpoint]]
***** [[./hay_neymotin_biophys_compare/apical88.png][apical oblique]]
***** [[./hay_neymotin_biophys_compare/basal46.png][basal dendrite]]
**** possibly the result of constraining with just current step firing, as in hay cell it does lead to overall lower transfer impedances (still doesn't go to zero though)
***** [[./hay_composite_transfer/][comparisons of biophys from BAC and current step constraints]]
**** worth running M1 model w/ different PT cell model, or same morph different biophys, check for differences?
**** worth adjusting params to get rid of this effect?
*** Observations from Hay cell/biophys
**** input and transfer impedances are lowest when just constrained with current steps, highest just with BAC, in the middle with combo 
**** conversely span of peak frequencies is shifted up for current step firing, down for BAC firing 
***** differences in peak frequency don't seem attributable to gbar_Ih, main biophysical differences in Ca, K, and Na
**** M1 PT cell morphology with Hay biophys has fairly similar impedance profile to straight hay cells 
**** EEE cell more similar to Hay cell 
*** what does impedance tell us (kind of in response to ted's ba humbugging):
**** from dewell and Gabbiani: "stimulus selectivity arises from the precise spatiotemporal patterning of synaptic inputs (Jones and
Gabbiani 2010; Peron et al. 2007; Zhu and Gabbiani 2016) and complex dendritic computations, including filtering by active
conductances such as sodium, low voltage-activated calcium, calcium-dependent potassium, inactivating potassium, HCN".
**** ibid: "A neuronâ€™s frequency-dependent membrane properties are characterized by its impedance profile. The subthreshold impedance can be
decomposed into input impedance (ZIN), which describes local change in Vm at the site of an input current, and transfer impedance (ZTR),
which describes change in Vm at remote locations after propagation through the neuron. Both ZIN and ZTR shape synaptic integration
within dendrites. Additionally, impedance properties at the site of spike initiation influence the transformation of Vm into spiking activity, 
including the frequency filtering and timing of a neuronâ€™s output. If a neuronâ€™s conductance distribution is uniform, then ZTR and ZIN 
will have similar properties. When it is not, the impedance profile varies by location and transfer depends on the recording locations and
the direction of signal propagation (Hu et al. 2009; Vaidya and Johnston 2013)."

* [2020-1-8 Wed]
** set up Hay cell for input impedance everywhere and transfer impedance to soma from everywhere
*** M1 and EEE too, never redid after poster
*** Hay cell running on pt, my, no; M1 PT running on pi 

* [2020-1-9 Thu]
** code for comparing transfer impedance with PT morph and different biophys
cmap = colormap('jet');
path = '/home/craig/Documents/Neurosim_Lab/dendritic_resonance/recordFromAll_hayShep/chirp_shepMorph/';
path2 = '/home/craig/Documents/Neurosim_Lab/dendritic_resonance/recordFromAll_data_PT/mat/';
l = dir(path);
l2 = dir(path2);
for i = 1:length(l)
    if ~l(i).isdir
        load(strcat(path,l(i).name))
        path_lengths_pt = path_lengths;
        transferImped_pt = transferImped;
        transferResFreq_pt = transferResFreq;

        load(strcat(path2,l2(i).name))
        path_lengths_hay = path_lengths;
        transferImped_hay = transferImped;
        transferResFreq_hay = transferResFreq;

        transferResFreq = [transferResFreq_pt, transferResFreq_hay];
        inds = floor(((transferResFreq-min(transferResFreq)))/(max(transferResFreq)-min(transferResFreq))*63)+1;
        count = 1;
        
        figure('units','normalized','outerposition',[0 0 1 1]);
        subplot(1,2,1)
        hold on
        for j = 1:length(transferResFreq_pt)
            plot(path_lengths_pt(j), transferImped_pt(j), 'o', 'Color', cmap(inds(count),:), 'LineWidth', 2)
            count = count + 1;
        end
        title(l(i).name(1:end-6))
        xlabel('Distance (\mum)')
        ylabel('Transfer Impedance (M\Omega)')

        subplot(1,2,2)
        hold on
        for j = 1:length(transferResFreq_hay)
            plot(path_lengths_hay(j), transferImped_hay(j), 'o', 'Color', cmap(inds(count),:), 'LineWidth', 2)
            count = count + 1;
        end
        colormap('jet')
        colorbar
        caxis([min(transferResFreq), max(transferResFreq)])
        title(l(i).name(1:end-6))
        xlabel('Distance (\mum)')
        ylabel('Transfer Impedance (M\Omega)')
    end
    keep cmap path l path2 l2 
end
** notes from meeting with bill
*** bill will email ben suter about morphology (inform folks what may be wrong with PT)
*** hippocampus thin v thick?, neuromorpho neocortex thin v thick 
*** is transfer impedance really a misnomer (ask ted)
*** capture changes in shape (q-value/factor)
*** are we using EEE cell? if so, ask srdjan (bill)
*** double check if EEE is thin or thick
*** small changes 25-50% to biophys, big batches, switch to netpyne
*** combos of stims based on inputs and/or transfer impedances, start sinusoidal, move to synaptic 
*** possibly (probably) going to drop PT cell from M1 model

* [2020-1-10 Fri]
** plotting input and tranfer to soma for hay's cell
load biophys1_data.mat
indsSoma = floor(((resFreqSoma-min(resFreqSoma)))/(max(resFreqSoma)-min(resFreqSoma))*63)+1;
indsCis = floor(((resFreqCis-min(resFreqCis)))/(max(resFreqCis)-min(resFreqCis))*63)+1;

figure('units','normalized','outerposition',[0 0 1 1]);
hold on
cmap = colormap('jet');
for j = 1:length(resFreqSoma)
    plot(dists(j), maxSoma(j), 'o', 'Color', cmap(indsSoma(j),:), 'LineWidth', 2)
end
colormap('jet')
colorbar
caxis([min(resFreqSoma), max(resFreqSoma)])
xlabel('Distance to Soma (\mum)')
ylabel('Transfer Impedance to Soma (M\Omega)')

figure('units','normalized','outerposition',[0 0 1 1]);
hold on
cmap = colormap('jet');
for j = 1:length(resFreqCis)
    plot(dists(j), maxCis(j), 'o', 'Color', cmap(indsCis(j),:), 'LineWidth', 2)
end
colormap('jet')
colorbar
caxis([min(resFreqCis), max(resFreqCis)])
xlabel('Distance to Soma (\mum)')
ylabel('Input Impedance (M\Omega)')
** rerunning with biophys 1 for al
* [2020-1-14 Tue] - adding analyses simlar to Dewell and Gabbiani
*** new function for impedance measures 
def getZmeasures(current, v_cis, v_soma, delay, sampr, f1, bwinsz=1):
    from pylab import fft, convolve
    # zero padding
    current = current[int(delay*sampr - 0.5*sampr+1):-int(delay*sampr- 0.5*sampr)]
    current = np.hstack((np.repeat(current[0],int(delay*sampr)),current, np.repeat(current[-1], int(delay*sampr))))
    current = current - np.mean(current)
    v_cis = v_cis[int(delay*sampr - 0.5*sampr)+1:-int(delay*sampr - 0.5*sampr)]
    v_cis = np.hstack((np.repeat(v_cis[0],int(delay*sampr)), v_cis, np.repeat(v_cis[-1], int(delay*sampr))))
    v_cis = v_cis - np.mean(v_cis)
    v_soma = v_soma[int(delay*sampr - 0.5*sampr)+1:-int(delay*sampr - 0.5*sampr)]
    v_soma = np.hstack((np.repeat(v_soma[0],int(delay*sampr)), v_soma, np.repeat(v_soma[-1], int(delay*sampr))))
    v_soma = v_soma - np.mean(v_soma)

    # input and transfer impedance
    f_current = (fft(current)/len(current))[0:int(len(current)/2)]
    f_cis = (fft(v_cis)/len(v_cis))[0:int(len(v_cis)/2)]
    f_soma = (fft(v_soma)/len(v_soma))[0:int(len(v_soma)/2)]
    Zin = f_cis / f_current
    Zc = f_soma / f_current

    # impedance measures
    Freq         = np.linspace(0.0, sampr/2.0, len(Zin))
    ZinAmp       = abs(Zin)
    ZinPhase     = np.arctan(np.imag(Zin)/np.real(Zin))
    ZinRes       = np.real(Zin)
    ZinReact     = np.imag(Zin)
    ZcAmp        = abs(Zc)
    ZcPhase      = np.arctan(np.imag(Zc)/np.real(Zc))
    ZcRes        = np.real(Zc)
    ZcReact      = np.imag(Zc)
    phase_lag    = ZinPhase - ZcPhase
    Vattenuation = (ZinAmp-ZcAmp) / ZinAmp

    # smoothing
    fblur = np.array([1.0/bwinsz for i in range(bwinsz)])
    ZinAmp = convolve(ZinAmp,fblur,'same')
    ZcAmp = convolve(ZcAmp,fblur,'same')

    # trim
    mask = (Freq >= 0.5) & (Freq <= 20)
    Freq, ZinAmp, ZinPhase, ZinRes, ZinReact, ZcAmp, ZcPhase, ZcRes, ZcReact, phase_lag, Vattenuation = Freq[mask], ZinAmp[mask], ZinPhase[mask], ZinRes[mask], ZinReact[mask], ZcAmp[mask], ZcPhase[mask], ZcRes[mask], ZcReact[mask], phase_lag[mask], Vattenuation[mask]
    
    # resonance
    ZinResAmp    = np.max(ZinAmp)
    ZinResFreq   = Freq[np.argmax(ZinAmp)]
    ZcResAmp     = np.max(ZcAmp)
    ZcResFreq    = Freq[np.argmax(ZcAmp)]
    QfactorIn    = ZinResAmp / ZinAmp[0]
    QfactorTrans = ZcResAmp / ZcAmp[0]
    fVarIn       = np.std(ZinAmp) / np.mean(ZinAmp)
    fVarTrans    = np.std(ZcAmp) / np.mean(ZcAmp)

    return Freq, ZinRes, ZinReact, ZinAmp, ZinPhase, ZinRes, ZinReact, ZcAmp, ZcPhase, phase_lag, Vattenuation,ZinResAmp, ZinResFreq, ZcResAmp, ZcResFreq, QfactorIn, QfactorTrans, fVarIn, fVarTrans

* [2020-1-15 Wed]
** plotting outout from a couple examples
*** EEE
from scipy.io import loadmat
from matplotlib import pyplot as plt
import numpy as np
data_apic15 = loadmat('./apical[15].json.mat')
data_apic34 = loadmat('./apical[34].json.mat')
data_apic7 = loadmat('./apical[7].json.mat')
data_basal8 = loadmat('./basal[8].json.mat')
# input impedance phase
plt.plot(data_basal8['Freq'][0], data_basal8['ZinPhase'][0], label='Basal')
plt.plot(data_apic34['Freq'][0], data_apic34['ZinPhase'][0], label='Apical Oblique')
plt.plot(data_apic7['Freq'][0],  data_apic7['ZinPhase'][0], label='Apical Trunk')
plt.plot(data_apic15['Freq'][0], data_apic15['ZinPhase'][0], label='Apical Tuft')
plt.xlabel('Frequency (Hz)')
plt.ylabel('Input Impedance Phase (radians)')
plt.legend()
plt.show()
# normalized input impedance amplitude
plt.plot(data_basal8['Freq'][0], data_basal8['ZinAmp'][0] / np.max(data_basal8['ZinAmp'][0]), label='Basal')
plt.plot(data_apic34['Freq'][0], data_apic34['ZinAmp'][0] / np.max(data_apic34['ZinAmp'][0]), label='Apical Oblique')
plt.plot(data_apic7['Freq'][0],  data_apic7['ZinAmp'][0] / np.max(data_apic7['ZinAmp'][0]), label='Apical Trunk')
plt.plot(data_apic15['Freq'][0], data_apic15['ZinAmp'][0] / np.max(data_apic15['ZinAmp'][0]), label='Apical Tuft')
plt.xlabel('Frequency (Hz)')
plt.ylabel('Normalized Impedance Amplitude')
plt.legend()
plt.show()
# normalized transfer impedance amplitude
plt.plot(data_basal8['Freq'][0], data_basal8['ZcAmp'][0] / np.max(data_basal8['ZcAmp'][0]), label='Basal')
plt.plot(data_apic34['Freq'][0], data_apic34['ZcAmp'][0] / np.max(data_apic34['ZcAmp'][0]), label='Apical Oblique')
plt.plot(data_apic7['Freq'][0],  data_apic7['ZcAmp'][0] / np.max(data_apic7['ZcAmp'][0]), label='Apical Trunk')
plt.plot(data_apic15['Freq'][0], data_apic15['ZcAmp'][0] / np.max(data_apic15['ZcAmp'][0]), label='Apical Tuft')
plt.xlabel('Frequency (Hz)')
plt.ylabel('Normalized Impedance Amplitude')
plt.legend()
plt.show()
# input resistance vs input reactance
plt.plot(data_basal8['ZinRes'][0], data_basal8['ZinReact'][0], label='Basal')
plt.plot(data_apic34['ZinRes'][0], data_apic34['ZinReact'][0], label='Apical Oblique')
plt.plot(data_apic7['ZinRes'][0],  data_apic7['ZinReact'][0], label='Apical Trunk')
plt.plot(data_apic15['ZinRes'][0], data_apic15['ZinReact'][0], label='Apical Tuft')
plt.xlabel('Input Resistance (Hz)')
plt.ylabel('Input Reactance (radians)')
plt.legend()
plt.show()
# phase lag
plt.plot(data_basal8['Freq'][0], data_basal8['phase_lag'][0], label ='Basal') 
plt.plot(data_apic34['Freq'][0], data_apic34['phase_lag'][0], label ='Apical Oblique') 
plt.plot(data_apic7['Freq'][0],  data_apic7['phase_lag'][0], label ='Apical Trunk') 
plt.plot(data_apic15['Freq'][0], data_apic15['phase_lag'][0], label ='Apical Tuft')
plt.xlabel('Frequency (Hz)')
plt.ylabel('Phase Lag (radians)')
plt.legend()
plt.show()
*** Hay
from scipy.io import loadmat
from matplotlib import pyplot as plt
import numpy as np
data_apic6 = loadmat('./L5PCtemplate[0].apic[6].mat')
data_apic9 = loadmat('./L5PCtemplate[0].apic[9].mat')
data_apic58 = loadmat('./L5PCtemplate[0].apic[58].mat')
data_apic89 = loadmat('./L5PCtemplate[0].apic[89].mat')
data_dend12 = loadmat('./L5PCtemplate[0].dend[12].mat')
# input impedance phase
plt.plot(data_apic6['Freq'][0], data_apic6['ZinPhase'][0],   label = 'Apical 6')
plt.plot(data_apic9['Freq'][0], data_apic9['ZinPhase'][0],   label = 'Apical 9')
plt.plot(data_apic58['Freq'][0], data_apic58['ZinPhase'][0], label = 'Apical 58')
plt.plot(data_apic89['Freq'][0], data_apic89['ZinPhase'][0], label = 'Apical 89')
plt.plot(data_dend12['Freq'][0], data_dend12['ZinPhase'][0], label = 'Basal 12')
plt.xlabel('Frequency (Hz)')
plt.ylabel('Input Impedance Phase (radians)')
plt.legend()
plt.show()
# normalized input impedance amplitude
plt.plot(data_apic6['Freq'][0], data_apic6['ZinAmp'][0] / np.max(data_apic6['ZinAmp'][0]), label = 'Apical 6')
plt.plot(data_apic9['Freq'][0], data_apic9['ZinAmp'][0] / np.max(data_apic9['ZinAmp'][0]), label = 'Apical 9')
plt.plot(data_apic58['Freq'][0], data_apic58['ZinAmp'][0] / np.max(data_apic58['ZinAmp'][0]), label = 'Apical 58')
plt.plot(data_apic89['Freq'][0], data_apic89['ZinAmp'][0] / np.max(data_apic89['ZinAmp'][0]), label = 'Apical 89')
plt.plot(data_dend12['Freq'][0], data_dend12['ZinAmp'][0] / np.max(data_dend12['ZinAmp'][0]), label = 'Basal 12')
plt.xlabel('Frequency (Hz)')
plt.ylabel('Normalized Input Impedance Amplitude')
plt.legend()
plt.show()
# phase lag
plt.plot(data_apic6['Freq'][0], data_apic6['phase_lag'][0], label =   'Apical 6')
plt.plot(data_apic9['Freq'][0], data_apic9['phase_lag'][0], label =   'Apical 9')
plt.plot(data_apic58['Freq'][0], data_apic58['phase_lag'][0], label = 'Apical 58')
plt.plot(data_apic89['Freq'][0], data_apic89['phase_lag'][0], label = 'Apical 89')
plt.plot(data_dend12['Freq'][0], data_dend12['phase_lag'][0], label = 'Basal 12')
plt.xlabel('Frequency (Hz)')
plt.ylabel('Phase Lag (radians)')
plt.legend()
plt.show()
# normalized transfer impedance
plt.plot(data_apic6['Freq'][0], data_apic6['ZcAmp'][0] / np.max(data_apic6['ZcAmp'][0]), label ='Apical 6')
plt.plot(data_apic9['Freq'][0], data_apic9['ZcAmp'][0] / np.max(data_apic9['ZcAmp'][0]), label ='Apical 9')
plt.plot(data_apic58['Freq'][0], data_apic58['ZcAmp'][0] / np.max(data_apic58['ZcAmp'][0]), label = 'Apical 58')
plt.plot(data_apic89['Freq'][0], data_apic89['ZcAmp'][0] / np.max(data_apic89['ZcAmp'][0]), label = 'Apical 89')
plt.plot(data_dend12['Freq'][0], data_dend12['ZcAmp'][0] / np.max(data_dend12['ZcAmp'][0]), label = 'Basal 12')
plt.xlabel('Frequency (Hz)')
plt.ylabel('Normalized Transfer Impedance Amplitude')
plt.legend()
plt.show()
* [2020-1-16 Thu]
** running input and transfer to soma impedance for all segments for EEE and hay
** extending to Kole cell
*** stitched intiate_neuron.hoc and A3+AIS_original.hoc into cell template
*** running chirp examples on *my*
*** plotting output
from scipy.io import loadmat
from matplotlib import pyplot as plt
import numpy as np
data_apic15 = loadmat('./KoleCell[0].apic[15]_v2.mat')
data_apic34 = loadmat('./KoleCell[0].apic[34]_v2.mat')
data_apic60  = loadmat('./KoleCell[0].apic[60]_v2.mat')
data_basal8 = loadmat('./KoleCell[0].dend[8]_v2.mat')
# input impedance phase
plt.plot(data_apic15['Freq'][0], data_apic15['ZinPhase'][0], label='Apical 15')
plt.plot(data_apic34['Freq'][0], data_apic34['ZinPhase'][0], label='Apical 34')
plt.plot(data_apic60['Freq'][0],  data_apic60['ZinPhase'][0],label='Apical 60')
plt.plot(data_basal8['Freq'][0], data_basal8['ZinPhase'][0], label='Basal 8')
plt.xlabel('Frequency (Hz)')
plt.ylabel('Input Impedance Phase (radians)')
plt.legend()
plt.show()
# normalized input impedance amplitude
plt.plot(data_apic15['Freq'][0], data_apic15['ZinAmp'][0] / np.max(data_apic15['ZinAmp'][0]),label='Apical 15')
plt.plot(data_apic34['Freq'][0], data_apic34['ZinAmp'][0] / np.max(data_apic34['ZinAmp'][0]),label='Apical 34')
plt.plot(data_apic60['Freq'][0], data_apic60['ZinAmp'][0] / np.max(data_apic60['ZinAmp'][0]), label='Apical 60')
plt.plot(data_basal8['Freq'][0], data_basal8['ZinAmp'][0] / np.max(data_basal8['ZinAmp'][0]),label='Basal 8')
plt.xlabel('Frequency (Hz)')
plt.ylabel('Normalized Impedance Amplitude')
plt.legend()
plt.show()
# normalized transfer impedance amplitude
plt.plot(data_apic15['Freq'][0], data_apic15['ZcAmp'][0] / np.max(data_apic15['ZcAmp'][0]), label='Apical 15')
plt.plot(data_apic34['Freq'][0], data_apic34['ZcAmp'][0] / np.max(data_apic34['ZcAmp'][0]), label='Apical 34')
plt.plot(data_apic60['Freq'][0], data_apic60['ZcAmp'][0] / np.max(data_apic60['ZcAmp'][0]),   label='Apical 60')
plt.plot(data_basal8['Freq'][0], data_basal8['ZcAmp'][0] / np.max(data_basal8['ZcAmp'][0]), label='Basal 8')
plt.xlabel('Frequency (Hz)')
plt.ylabel('Normalized Impedance Amplitude')
plt.legend()
plt.show()
# input resistance vs input reactance
plt.plot(data_apic15['ZinRes'][0], data_apic15['ZinReact'][0], label='Apical 15')
plt.plot(data_apic34['ZinRes'][0], data_apic34['ZinReact'][0], label='Apical 34')
plt.plot(data_apic60['ZinRes'][0], data_apic60['ZinReact'][0],  label='Apical 60')
plt.plot(data_basal8['ZinRes'][0], data_basal8['ZinReact'][0], label='Basal 8')
plt.xlabel('Input Resistance (Hz)')
plt.ylabel('Input Reactance (radians)')
plt.legend()
plt.show()
# phase lag
plt.plot(data_apic15['Freq'][0], data_apic15['phase_lag'][0], label='Apical 15')
plt.plot(data_apic34['Freq'][0], data_apic34['phase_lag'][0], label='Apical 34')
plt.plot(data_apic60['Freq'][0], data_apic60['phase_lag'][0],  label='Apical 60')
plt.plot(data_basal8['Freq'][0], data_basal8['phase_lag'][0], label='Basal 8')
plt.xlabel('Frequency (Hz)')
plt.ylabel('Phase Lag (radians)')
plt.legend()
plt.show()
** eee apical - pi, eee basal - my, hay apical - el, kole all - no

* [2020-1-21 Tue] plotting results from all input and transfer to soma impedances
** still running hay apical
** code for plotting output
file1 = load('inputAndTransfer_basal.mat');
file2 = load('inputAndTransfer_apical.mat');
ZinResAmp = [file1.ZinResAmp, file2.ZinResAmp];
ZinResFreq = [file1.ZinResFreq, file2.ZinResFreq];
ZcResAmp = [file1.ZcResAmp, file2.ZcResAmp];
ZcResFreq = [file1.ZcResFreq, file2.ZcResFreq];
dist = [file1.dist, file2.dist];
QfactorIn = [file1.QfactorIn, file2.QfactorIn];
QfactorTrans = [file1.QfactorTrans, file2.QfactorTrans];
fVarIn = [file1.fVarIn, file2.fVarIn];
fVarTrans = [file1.fVarTrans, file2.fVarTrans];

* [2020-1-22 Wed]
** got template for Combe Et Al Ca1 pyramidal neuron up and running
*** running a few example runs
** running trimmed version of inputAndTransfer_apical_cut.py on *pi* (starting 4:06) - see how long this takes . . . 

* [2020-1-25 Sat] - adding play into iclamp to netpyne
** Salva's code from LASCON
# Create network and run simulation
sim.create(netParams = netParams, simConfig = simConfig)
...
netParams.stimSourceParams['iclamp'] = {'type': 'IClamp', 'amp': 0.0, 'dur': 1000, 'delay': 0}
netParams.stimTargetParams['iclamp->PYR'] = {'source': 'iclamp', 'conds': {'pop': 'S'}, 'sec': 'soma', 'loc': 0.5}
...
init_amp = 0.0
peak_amp = 0.24
ramp_up = np.linspace(init_amp, peak_amp, simConfig.duration/(simConfig.dt))
t = h.Vector(np.arange(0,simConfig.duration, simConfig.dt))
amp = h.Vector(ramp_up)
for cell in sim.net.cells:
    try:
        amp.play(cell.stims[0]['hObj']._ref_amp, t, True)
    except:
        pass
sim.simulate()
sim.analyze()
** "similar approach to modify gnabar via vector.play():"
init_amp = 0.0
peak_amp = 0.24
ramp_up = np.linspace(init_amp, peak_amp, simConfig.duration/(simConfig.dt))
t = h.Vector(np.arange(0,simConfig.duration, simConfig.dt))
amp = h.Vector(ramp_up)
for cell in sim.net.cells:
    amp.play(cell.secs['soma']['hObj'](0.5).hh._ref_gnabar, t, True)
* [2020-1-27 Mon] - changing Ih and Im
** did this for Kole cell apical tuft as example
*** code for generating figs in matlab:
fVarInMat = zeros(3,3);
fVarCMat = zeros(3,3);
QfactorInMat = zeros(3,3);
QfactorCMat = zeros(3,3);
ZinResAmpMat = zeros(3,3);
ZcResAmpMat = zeros(3,3);
ZinResFreqMat = zeros(3,3);
ZcResFreqMat = zeros(3,3);
load('KoleCell[0].apic[86]_km_-0.25_ih_-0.25.mat')
fVarInMat(1,1) = fVarIn;
fVarCMat(1,1) = fVarTrans;
QfactorInMat(1,1) = QfactorIn;
QfactorCMat(1,1) = QfactorTrans;
ZinResAmpMat(1,1) = ZinResAmp;
ZcResAmpMat(1,1) = ZcResAmp;
ZinResFreqMat(1,1) = ZinResFreq;
ZcResFreqMat(1,1) = ZcResFreq;
load('KoleCell[0].apic[86]_km_-0.25_ih_0.mat')
fVarInMat(1,2) = fVarIn;
fVarCMat(1,2) = fVarTrans;
QfactorInMat(1,2) = QfactorIn;
QfactorCMat(1,2) = QfactorTrans;
ZinResAmpMat(1,2) = ZinResAmp;
ZcResAmpMat(1,2) = ZcResAmp;
ZinResFreqMat(1,2) = ZinResFreq;
ZcResFreqMat(1,2) = ZcResFreq;
load('KoleCell[0].apic[86]_km_-0.25_ih_0.25.mat')
fVarInMat(1,3) = fVarIn;
fVarCMat(1,3) = fVarTrans;
QfactorInMat(1,3) = QfactorIn;
QfactorCMat(1,3) = QfactorTrans;
ZinResAmpMat(1,3) = ZinResAmp;
ZcResAmpMat(1,3) = ZcResAmp;
ZinResFreqMat(1,3) = ZinResFreq;
ZcResFreqMat(1,3) = ZcResFreq;
load('KoleCell[0].apic[86]_km_0_ih_-0.25.mat')
fVarInMat(2,1) = fVarIn;
fVarCMat(2,1) = fVarTrans;
QfactorInMat(2,1) = QfactorIn;
QfactorCMat(2,1) = QfactorTrans;
ZinResAmpMat(2,1) = ZinResAmp;
ZcResAmpMat(2,1) = ZcResAmp;
ZinResFreqMat(2,1) = ZinResFreq;
ZcResFreqMat(2,1) = ZcResFreq;
load('KoleCell[0].apic[86]_km_0_ih_0.mat')
fVarInMat(2,2) = fVarIn;
fVarCMat(2,2) = fVarTrans;
QfactorInMat(2,2) = QfactorIn;
QfactorCMat(2,2) = QfactorTrans;
ZinResAmpMat(2,2) = ZinResAmp;
ZcResAmpMat(2,2) = ZcResAmp;
ZinResFreqMat(2,2) = ZinResFreq;
ZcResFreqMat(2,2) = ZcResFreq;
load('KoleCell[0].apic[86]_km_0_ih_0.25.mat')
fVarInMat(2,3) = fVarIn;
fVarCMat(2,3) = fVarTrans;
QfactorInMat(2,3) = QfactorIn;
QfactorCMat(2,3) = QfactorTrans;
ZinResAmpMat(2,3) = ZinResAmp;
ZcResAmpMat(2,3) = ZcResAmp;
ZinResFreqMat(2,3) = ZinResFreq;
ZcResFreqMat(2,3) = ZcResFreq;
load('KoleCell[0].apic[86]_km_0.25_ih_-0.25.mat')
fVarInMat(3,1) = fVarIn;
fVarCMat(3,1) = fVarTrans;
QfactorInMat(3,1) = QfactorIn;
QfactorCMat(3,1) = QfactorTrans;
ZinResAmpMat(3,1) = ZinResAmp;
ZcResAmpMat(3,1) = ZcResAmp;
ZinResFreqMat(3,1) = ZinResFreq;
ZcResFreqMat(3,1) = ZcResFreq;
load('KoleCell[0].apic[86]_km_0.25_ih_0.mat')
fVarInMat(3,2) = fVarIn;
fVarCMat(3,2) = fVarTrans;
QfactorInMat(3,2) = QfactorIn;
QfactorCMat(3,2) = QfactorTrans;
ZinResAmpMat(3,2) = ZinResAmp;
ZcResAmpMat(3,2) = ZcResAmp;
ZinResFreqMat(3,2) = ZinResFreq;
ZcResFreqMat(3,2) = ZcResFreq;
load('KoleCell[0].apic[86]_km_0.25_ih_0.25.mat')
fVarInMat(3,3) = fVarIn;
fVarCMat(3,3) = fVarTrans;
QfactorInMat(3,3) = QfactorIn;
QfactorCMat(3,3) = QfactorTrans;
ZinResAmpMat(3,3) = ZinResAmp;
ZcResAmpMat(3,3) = ZcResAmp;
ZinResFreqMat(3,3) = ZinResFreq;
ZcResFreqMat(3,3) = ZcResFreq;
% input impedance amplitude
figure()
imagesc([-0.25,0,0.25], [-0.25,0,0.25], ZinResAmpMat)
colormap('jet')
colorbar
set(gca,'YDir','normal')
xticks([-0.25,0,0.25])
yticks([-0.25,0,0.25])
xticklabels({'-25%', '+0%', '+25%'})
yticklabels({'-25%', '+0%', '+25%'})
xlabel('Change in Ih g_b_a_r')
ylabel('Change in Im g_b_a_r')
title('Peak Input Impedance Amplitude')
% input impedance peak frequency
figure()
imagesc([-0.25,0,0.25], [-0.25,0,0.25], ZinResFreqMat)
colormap('jet')
colorbar
set(gca,'YDir','normal')
xticks([-0.25,0,0.25])
yticks([-0.25,0,0.25])
xticklabels({'-25%', '+0%', '+25%'})
yticklabels({'-25%', '+0%', '+25%'})
xlabel('Change in Ih g_b_a_r')
ylabel('Change in Im g_b_a_r')
title('Peak Input Impedance Frequency')
% transfer impedance amplitude
figure()
imagesc([-0.25,0,0.25], [-0.25,0,0.25], ZcResAmpMat)
colormap('jet')
colorbar
set(gca,'YDir','normal')
xticks([-0.25,0,0.25])
yticks([-0.25,0,0.25])
xticklabels({'-25%', '+0%', '+25%'})
yticklabels({'-25%', '+0%', '+25%'})
xlabel('Change in Ih g_b_a_r')
ylabel('Change in Im g_b_a_r')
title('Peak Transfer Impedance Amplitude')
% transfer impedance peak frequency
figure()
imagesc([-0.25,0,0.25], [-0.25,0,0.25], ZinResFreqMat)
colormap('jet')
colorbar
set(gca,'YDir','normal')
xticks([-0.25,0,0.25])
yticks([-0.25,0,0.25])
xticklabels({'-25%', '+0%', '+25%'})
yticklabels({'-25%', '+0%', '+25%'})
xlabel('Change in Ih g_b_a_r')
ylabel('Change in Im g_b_a_r')
title('Peak Transfer Impedance Frequency')
% input impedance qfactor
figure()
imagesc([-0.25,0,0.25], [-0.25,0,0.25], QfactorInMat)
colormap('jet')
colorbar
set(gca,'YDir','normal')
xticks([-0.25,0,0.25])
yticks([-0.25,0,0.25])
xticklabels({'-25%', '+0%', '+25%'})
yticklabels({'-25%', '+0%', '+25%'})
xlabel('Change in Ih g_b_a_r')
ylabel('Change in Im g_b_a_r')
title('Input Impedance Q-factor')
% transfer impedance qfactor
figure()
imagesc([-0.25,0,0.25], [-0.25,0,0.25], QfactorCMat)
colormap('jet')
colorbar
set(gca,'YDir','normal')
xticks([-0.25,0,0.25])
yticks([-0.25,0,0.25])
xticklabels({'-25%', '+0%', '+25%'})
yticklabels({'-25%', '+0%', '+25%'})
xlabel('Change in Ih g_b_a_r')
ylabel('Change in Im g_b_a_r')
title('Transfer Impedance Q-factor')
% input impedance fvar
figure()
imagesc([-0.25,0,0.25], [-0.25,0,0.25], QfactorInMat)
colormap('jet')
colorbar
set(gca,'YDir','normal')
xticks([-0.25,0,0.25])
yticks([-0.25,0,0.25])
xticklabels({'-25%', '+0%', '+25%'})
yticklabels({'-25%', '+0%', '+25%'})
xlabel('Change in Ih g_b_a_r')
ylabel('Change in Im g_b_a_r')
title('Input Impedance f_v_a_r')
% transfer impedance fvar
figure()
imagesc([-0.25,0,0.25], [-0.25,0,0.25], QfactorCMat)
colormap('jet')
colorbar
set(gca,'YDir','normal')
xticks([-0.25,0,0.25])
yticks([-0.25,0,0.25])
xticklabels({'-25%', '+0%', '+25%'})
yticklabels({'-25%', '+0%', '+25%'})
xlabel('Change in Ih g_b_a_r')
ylabel('Change in Im g_b_a_r')
title('Transfer Impedance f_v_a_r')
* [2020-1-28 Tue]
** plotted input impedance at multiple locations stuff
** screwed up saving transfer data, have to rerun
** salva pointed me toward example of loading allen institute cells [[../my_netwpyne/examples/saveLoadV1/][load allen institute cells example]]
*** some errors when running *getCells()* from *getCells.py*:
cp: cannot stat 'E2/cell_template.hoc': No such file or directory
Creating x86_64 directory for .o files.

/u/craig/my_netpyne/examples/saveLoadV1
./E2/modfiles
modfiles
make: No rule to make target 'modfiles.mod', needed by 'modfiles.lo'.  Stop.
** plotting input and transfer impedance for examples 
*** eee
cd /pt/u
figure('units','normalized','outerposition',[0 0 1 1]);
load('basal[8]_traces.mat');
time = linspace(-5,25,length(cis_np));
cis_np = cis_np(time >= -1 & time <= 21);
soma_np = soma_np(time >= -1 & time <= 21);
time = time(time >= -1 & time <= 21);
subplot(6,3,1)
plot(time, cis_np - cis_np(1), 'b', 'LineWidth', 1)
xlim([-1,21])
title('Basal Dendrite')
subplot(6,3,4)
plot(time, soma_np - soma_np(1), 'b', 'LineWidth', 1)
xlim([-1,21])
ylabel('Change in Membrane Potential (mV)')
clear

load('apical[34]_traces.mat');
time = linspace(-5,25,length(cis_np));
cis_np = cis_np(time >= -1 & time <= 21);
soma_np = soma_np(time >= -1 & time <= 21);
time = time(time >= -1 & time <= 21);
subplot(6,3,2)
plot(time, cis_np - cis_np(1), 'r', 'LineWidth', 1)
xlim([-1,21])
title('Apical Oblique')
subplot(6,3,5)
plot(time, soma_np - soma_np(1), 'r', 'LineWidth', 1)
xlim([-1,21])
title('Soma')
xlabel('Time (s)')
clear

load('apical[15]_traces.mat');
time = linspace(-5,25,length(cis_np));
cis_np = cis_np(time >= -1 & time <= 21);
soma_np = soma_np(time >= -1 & time <= 21);
time = time(time >= -1 & time <= 21);
subplot(6,3,3)
plot(time, cis_np - cis_np(1), 'g', 'LineWidth', 1)
xlim([-1,21])
title('Apical Tuft')
subplot(6,3,6)
plot(time, soma_np - soma_np(1), 'g', 'LineWidth', 1)
xlim([-1,21])
title('Soma')
xlabel('Time (s)')
clear

basal = load('basal[8].mat');
obliq = load('apical[34].mat');
tuft  = load('apical[15].mat');

subplot(3,3,4)
plot(basal.ZinRes - basal.ZinRes(1), basal.ZinReact - basal.ZinReact(1), 'b', 'lineWidth', 2)
hold on
plot(obliq.ZinRes - obliq.ZinRes(1), obliq.ZinReact - obliq.ZinReact(1), 'r', 'lineWidth', 2)
plot(tuft.ZinRes - tuft.ZinRes(1), tuft.ZinReact - tuft.ZinReact(1), 'g', 'lineWidth', 2)
xlabel('Change in Resistance (M\Omega)')
ylabel('Change in Reactance (M\Omega)')
title('Complex Input Impedance')
subplot(3,3,7)
plot(basal.ZcRes - basal.ZcRes(1), basal.ZcReact - basal.ZcReact(1), 'b', 'lineWidth', 2)
hold on
plot(obliq.ZcRes - obliq.ZcRes(1), obliq.ZcReact - obliq.ZcReact(1), 'r', 'lineWidth', 2)
plot(tuft.ZcRes - tuft.ZcRes(1), tuft.ZcReact - tuft.ZcReact(1), 'g', 'lineWidth', 2)
xlabel('Change in Resistance (M\Omega)')
ylabel('Change in Reactance (M\Omega)')
title('Complex Transfer Impedance')

subplot(3,3,5)
plot(basal.Freq, basal.ZinAmp / max(basal.ZinAmp), 'b', 'lineWidth', 2)
hold on
plot(obliq.Freq, obliq.ZinAmp / max(obliq.ZinAmp), 'r', 'lineWidth', 2)
plot(tuft.Freq, tuft.ZinAmp / max(tuft.ZinAmp), 'g', 'lineWidth', 2)
xlabel('Frequency (Hz)')
ylabel('Normalized Amplitude (a.u.)')
title('Input Impedance Amplitude')
subplot(3,3,8)
plot(basal.Freq, basal.ZcAmp / max(basal.ZcAmp), 'b', 'lineWidth', 2)
hold on
plot(obliq.Freq, obliq.ZcAmp / max(obliq.ZcAmp), 'r', 'lineWidth', 2)
plot(tuft.Freq, tuft.ZcAmp / max(tuft.ZcAmp), 'g', 'lineWidth', 2)
xlabel('Frequency (Hz)')
ylabel('Normalized Amplitude (a.u.)')
title('Transfer Impedance Amplitude')

subplot(3,3,6)
plot(basal.Freq, basal.ZinPhase, 'b', 'lineWidth', 2)
hold on
plot(obliq.Freq, obliq.ZinPhase, 'r', 'lineWidth', 2)
plot(tuft.Freq, tuft.ZinPhase, 'g', 'lineWidth', 2)
xlabel('Frequency (Hz)')
ylabel('Phase (radians)')
title('Input Impedance Phase')
subplot(3,3,9)
plot(basal.Freq, basal.ZcPhase, 'b', 'lineWidth', 2)
hold on
plot(obliq.Freq, obliq.ZcPhase, 'r', 'lineWidth', 2)
plot(tuft.Freq, tuft.ZcPhase, 'g', 'lineWidth', 2)
xlabel('Frequency (Hz)')
ylabel('Phase (radians)')
title('Transfer Impedance Phase')



*** kole
figure('units','normalized','outerposition',[0 0 1 1]);
load('KoleCell[0].dend[15]_traces.mat');
time = linspace(-5,55,length(cis_np));
cis_np = cis_np(time >= -1 & time <= 51);
soma_np = soma_np(time >= -1 & time <= 51);
time = time(time >= -1 & time <= 51);
subplot(6,3,1)
plot(time, cis_np - cis_np(1), 'b', 'LineWidth', 1)
xlim([-1,21])
title('Basal Dendrite')
subplot(6,3,4)
plot(time, soma_np - soma_np(1), 'b', 'LineWidth', 1)
xlim([-1,21])
ylabel('Change in Membrane Potential (mV)')
clear

load('KoleCell[0].apic[34]_traces.mat');
time = linspace(-5,55,length(cis_np));
cis_np = cis_np(time >= -1 & time <= 51);
soma_np = soma_np(time >= -1 & time <= 51);
time = time(time >= -1 & time <= 51);
subplot(6,3,2)
plot(time, cis_np - cis_np(1), 'r', 'LineWidth', 1)
xlim([-1,21])
title('Apical Oblique')
subplot(6,3,5)
plot(time, soma_np - soma_np(1), 'r', 'LineWidth', 1)
xlim([-1,21])
title('Soma')
xlabel('Time (s)')
clear

load('KoleCell[0].apic[82]_traces.mat');
time = linspace(-5,55,length(cis_np));
cis_np = cis_np(time >= -1 & time <= 51);
soma_np = soma_np(time >= -1 & time <= 51);
time = time(time >= -1 & time <= 51);
subplot(6,3,3)
plot(time, cis_np - cis_np(1), 'g', 'LineWidth', 1)
xlim([-1,21])
title('Apical Tuft')
subplot(6,3,6)
plot(time, soma_np - soma_np(1), 'g', 'LineWidth', 1)
xlim([-1,21])
title('Soma')
xlabel('Time (s)')
clear

basal = load('KoleCell[0].dend[15].mat');
obliq = load('KoleCell[0].apic[34].mat');
tuft  = load('KoleCell[0].apic[82].mat');

subplot(3,3,4)
plot(basal.ZinRes - basal.ZinRes(1), basal.ZinReact - basal.ZinReact(1), 'b', 'lineWidth', 2)
hold on
plot(obliq.ZinRes - obliq.ZinRes(1), obliq.ZinReact - obliq.ZinReact(1), 'r', 'lineWidth', 2)
plot(tuft.ZinRes - tuft.ZinRes(1), tuft.ZinReact - tuft.ZinReact(1), 'g', 'lineWidth', 2)
xlabel('Change in Resistance (M\Omega)')
ylabel('Change in Reactance (M\Omega)')
title('Complex Input Impedance')
subplot(3,3,7)
plot(basal.ZcRes - basal.ZcRes(1), basal.ZcReact - basal.ZcReact(1), 'b', 'lineWidth', 2)
hold on
plot(obliq.ZcRes - obliq.ZcRes(1), obliq.ZcReact - obliq.ZcReact(1), 'r', 'lineWidth', 2)
plot(tuft.ZcRes - tuft.ZcRes(1), tuft.ZcReact - tuft.ZcReact(1), 'g', 'lineWidth', 2)
xlabel('Change in Resistance (M\Omega)')
ylabel('Change in Reactance (M\Omega)')
title('Complex Transfer Impedance')

subplot(3,3,5)
plot(basal.Freq, basal.ZinAmp / max(basal.ZinAmp), 'b', 'lineWidth', 2)
hold on
plot(obliq.Freq, obliq.ZinAmp / max(obliq.ZinAmp), 'r', 'lineWidth', 2)
plot(tuft.Freq, tuft.ZinAmp / max(tuft.ZinAmp), 'g', 'lineWidth', 2)
xlabel('Frequency (Hz)')
ylabel('Normalized Amplitude (a.u.)')
title('Input Impedance Amplitude')
subplot(3,3,8)
plot(basal.Freq, basal.ZcAmp / max(basal.ZcAmp), 'b', 'lineWidth', 2)
hold on
plot(obliq.Freq, obliq.ZcAmp / max(obliq.ZcAmp), 'r', 'lineWidth', 2)
plot(tuft.Freq, tuft.ZcAmp / max(tuft.ZcAmp), 'g', 'lineWidth', 2)
xlabel('Frequency (Hz)')
ylabel('Normalized Amplitude (a.u.)')
title('Transfer Impedance Amplitude')

subplot(3,3,6)
plot(basal.Freq, basal.ZinPhase, 'b', 'lineWidth', 2)
hold on
plot(obliq.Freq, obliq.ZinPhase, 'r', 'lineWidth', 2)
plot(tuft.Freq, tuft.ZinPhase, 'g', 'lineWidth', 2)
xlabel('Frequency (Hz)')
ylabel('Phase (radians)')
title('Input Impedance Phase')
subplot(3,3,9)
plot(basal.Freq, basal.ZcPhase, 'b', 'lineWidth', 2)
hold on
plot(obliq.Freq, obliq.ZcPhase, 'r', 'lineWidth', 2)
plot(tuft.Freq, tuft.ZcPhase, 'g', 'lineWidth', 2)
xlabel('Frequency (Hz)')
ylabel('Phase (radians)')
title('Transfer Impedance Phase')


*** hay
figure('units','normalized','outerposition',[0 0 1 1]);
load('L5PCtemplate[0].dend[12]_traces.mat');
time = linspace(-5,25,length(cis_np));
cis_np = cis_np(time >= -1 & time <= 21);
soma_np = soma_np(time >= -1 & time <= 21);
time = time(time >= -1 & time <= 21);
subplot(6,3,1)
plot(time, cis_np - cis_np(1), 'b', 'LineWidth', 1)
xlim([-1,21])
title('Basal Dendrite')
subplot(6,3,4)
plot(time, soma_np - soma_np(1), 'b', 'LineWidth', 1)
xlim([-1,21])
ylabel('Change in Membrane Potential (mV)')
clear

load('L5PCtemplate[0].apic[33]_traces.mat');
time = linspace(-5,25,length(cis_np));
cis_np = cis_np(time >= -1 & time <= 21);
soma_np = soma_np(time >= -1 & time <= 21);
time = time(time >= -1 & time <= 21);
subplot(6,3,2)
plot(time, cis_np - cis_np(1), 'r', 'LineWidth', 1)
xlim([-1,21])
title('Apical Oblique')
subplot(6,3,5)
plot(time, soma_np - soma_np(1), 'r', 'LineWidth', 1)
xlim([-1,21])
title('Soma')
xlabel('Time (s)')
clear

load('L5PCtemplate[0].apic[58]_traces.mat');
time = linspace(-5,25,length(cis_np));
cis_np = cis_np(time >= -1 & time <= 21);
soma_np = soma_np(time >= -1 & time <= 21);
time = time(time >= -1 & time <= 21);
subplot(6,3,3)
plot(time, cis_np - cis_np(1), 'g', 'LineWidth', 1)
xlim([-1,21])
title('Apical Tuft')
subplot(6,3,6)
plot(time, soma_np - soma_np(1), 'g', 'LineWidth', 1)
xlim([-1,21])
title('Soma')
xlabel('Time (s)')
clear

basal = load('L5PCtemplate[0].dend[12].mat');
obliq = load('L5PCtemplate[0].apic[33].mat');
tuft  = load('L5PCtemplate[0].apic[58].mat');

subplot(3,3,4)
plot(basal.ZinRes - basal.ZinRes(1), basal.ZinReact - basal.ZinReact(1), 'b', 'lineWidth', 2)
hold on
plot(obliq.ZinRes - obliq.ZinRes(1), obliq.ZinReact - obliq.ZinReact(1), 'r', 'lineWidth', 2)
plot(tuft.ZinRes - tuft.ZinRes(1), tuft.ZinReact - tuft.ZinReact(1), 'g', 'lineWidth', 2)
xlabel('Change in Resistance (M\Omega)')
ylabel('Change in Reactance (M\Omega)')
title('Complex Input Impedance')
subplot(3,3,7)
plot(basal.ZcRes - basal.ZcRes(1), basal.ZcReact - basal.ZcReact(1), 'b', 'lineWidth', 2)
hold on
plot(obliq.ZcRes - obliq.ZcRes(1), obliq.ZcReact - obliq.ZcReact(1), 'r', 'lineWidth', 2)
plot(tuft.ZcRes - tuft.ZcRes(1), tuft.ZcReact - tuft.ZcReact(1), 'g', 'lineWidth', 2)
xlabel('Change in Resistance (M\Omega)')
ylabel('Change in Reactance (M\Omega)')
title('Complex Transfer Impedance')

subplot(3,3,5)
plot(basal.Freq, basal.ZinAmp / max(basal.ZinAmp), 'b', 'lineWidth', 2)
hold on
plot(obliq.Freq, obliq.ZinAmp / max(obliq.ZinAmp), 'r', 'lineWidth', 2)
plot(tuft.Freq, tuft.ZinAmp / max(tuft.ZinAmp), 'g', 'lineWidth', 2)
xlabel('Frequency (Hz)')
ylabel('Normalized Amplitude (a.u.)')
title('Input Impedance Amplitude')
subplot(3,3,8)
plot(basal.Freq, basal.ZcAmp / max(basal.ZcAmp), 'b', 'lineWidth', 2)
hold on
plot(obliq.Freq, obliq.ZcAmp / max(obliq.ZcAmp), 'r', 'lineWidth', 2)
plot(tuft.Freq, tuft.ZcAmp / max(tuft.ZcAmp), 'g', 'lineWidth', 2)
xlabel('Frequency (Hz)')
ylabel('Normalized Amplitude (a.u.)')
title('Transfer Impedance Amplitude')

subplot(3,3,6)
plot(basal.Freq, basal.ZinPhase, 'b', 'lineWidth', 2)
hold on
plot(obliq.Freq, obliq.ZinPhase, 'r', 'lineWidth', 2)
plot(tuft.Freq, tuft.ZinPhase, 'g', 'lineWidth', 2)
xlabel('Frequency (Hz)')
ylabel('Phase (radians)')
title('Input Impedance Phase')
subplot(3,3,9)
plot(basal.Freq, basal.ZcPhase, 'b', 'lineWidth', 2)
hold on
plot(obliq.Freq, obliq.ZcPhase, 'r', 'lineWidth', 2)
plot(tuft.Freq, tuft.ZcPhase, 'g', 'lineWidth', 2)
xlabel('Frequency (Hz)')
ylabel('Phase (radians)')
title('Transfer Impedance Phase')

* [2020-2-1 Sat]
** Passive Normalization of Synaptic Integration Influenced by Dendritic Architecture
DAVID B. JAFFE1 AND NICHOLAS T. CARNEVALE2
1
Division of Life Sciences, University of Texas at San Antonio, San Antonio, Texas 78249; and 2
Department of Psychology,
Yale University, New Haven, Connecticut 06520
*** "For all neurons, there was no significant variation of Zc with location within higher-order dendrites."
**** 
** Strings on a Violin: Location Dependence of Frequency Tuning in Active Dendrites
Anindita Das 1, Rahul K. Rathour 2 and Rishikesh Narayanan1
*** "While the impedance amplitude profile defines the voltage-current relationship in terms of maximal subthreshold response, the
impedance phase profile quantifies the temporal dynamics between voltage and current. It has been shown that presence of inductive reactance 
in neuronal membrane causes the voltage response to lead the injected oscillatory current. The balance between capacitive and inductive reactances determines both the
optimal lead frequency and the frequency bandwidth over which the voltage leads the current, providing a potential mechanism by which the subthreshold membrane dynamics of the neuron
may maintain a phase relationship with an ongoing oscillation (Mauro, 1961; Cole, 1968; Sabah and Leibovic, 1969; Mauro et al., 1970; Hu et al., 2002, 2009; Ulrich, 2002; Cook et al.,
2007; Narayanan and Johnston, 2008; Vaidya and Johnston, 2013)."
*** "a consortium of intrinsic and network mechanims could convert subthreshold spectral selectivity to the suprathreshold regime or evoke emergent
suprathreshold selectivity dissociated from subthreshold resonance"
*** " How do neurons maintain robust location-dependent spectral selectivity in the face of regulation by several such parameters, with each of them exhibiting 
significant variability across neurons (even of the same subtype)?
Degeneracy, defined as the ability of a system to elicit similar functional outputs through disparate combinations of constituent components, proffers an ideal
construct for achieving such robustness (Edelman and Gally, 2001). Such degeneracy has been observed in several neuronal systems and at various scales for bringing
about robustness in distinct combinations of physiological properties"
*** "Suprathreshold spectral tuning has been less conclusively explored, with various efforts marred by the lack of a single well-defined metric to study it. d
Computational studies have demonstrated that the STA and STA-derived metrics could be used to perform similar quantifications as impedance
analysis (RattÃ© et al., 2013; Das and Narayanan, 2014, 2015). So an important future direction would be an application of these metrics to experimental 
data comprising somatic and dendritic recordings and ascertain the VGIC- and locationdependence of suprathreshold spectral tuning in neurons."
* [2020-2-5 Wed] - rerunning distance - impedance stuff to include phase measures
** kole cell - pt, m1 cell - el, hay apical - au, hay basal - ag, eee basal - no, eee apical - my
* [2020-2-13 Thu] - running varying global Ih and Im for Hay cell
** only Hay and Kole seem to have Im 
* [2020-2-16 Sun] - loading allen brain cells
** loading allen cells
*** had to make some changes to /netpyne/examples/saveLoadV1/ to load in perisomatic cell models
*** had to make further changes to *cell_utils.py* in order to load all-active cell models 
**** working but still need to upload to netpyne git
** failed attempt at pull request for saveLoadV1 example fixes:
(py36) craig@craig-GL63-8RC:~/Documents/Repos/my_netpyne/examples/saveLoadV1$ git commit -am 'Fixed bug with loading cells and added example of all-active cell model, which requires modifications to cell_utils.py'
[my_branch 1fe59d7c] Fixed bug with loading cells and added example of all-active cell model, which requires modifications to cell_utils.py
 5 files changed, 271 insertions(+), 139 deletions(-)
 create mode 100644 examples/saveLoadV1/AA/active_cell_utils.py
 create mode 100644 examples/saveLoadV1/E2/cell_template.hoc
 rewrite examples/saveLoadV1/E2/cell_utils.py (93%)
 rewrite examples/saveLoadV1/E4/cell_utils.py (93%)
(py36) craig@craig-GL63-8RC:~/Documents/Repos/my_netpyne/examples/saveLoadV1$ git push
fatal: The current branch my_branch has no upstream branch.
To push the current branch and set the remote as upstream, use

    git push --set-upstream origin my_branch

(py36) craig@craig-GL63-8RC:~/Documents/Repos/my_netpyne/examples/saveLoadV1$ git merge master
merge: master - not something we can merge

Did you mean this?
	9.4
(py36) craig@craig-GL63-8RC:~/Documents/Repos/my_netpyne/examples/saveLoadV1$ git merge 9.4
merge: 9.4 - not something we can merge
(py36) craig@craig-GL63-8RC:~/Documents/Repos/my_netpyne/examples/saveLoadV1$ git merge development
Already up to date.
(py36) craig@craig-GL63-8RC:~/Documents/Repos/my_netpyne/examples/saveLoadV1$ git status
On branch my_branch
Untracked files:
  (use "git add <file>..." to include in what will be committed)

	../../.buildconfig
	E4/320207381.nwb
	E4/320207387_fit.json
	E4/Scnn1a-Tg3-Cre_Ai14-170426.03.01.01_491392845_m.swc
	E4/Scnn1a-Tg3-Cre_Ai14-170426.03.01.01_491392845_marker_m.swc
	E4/cell_template.hoc
	E4/manifest.json
	E4/modfiles/

nothing added to commit but untracked files present (use "git add" to track)
(py36) craig@craig-GL63-8RC:~/Documents/Repos/my_netpyne/examples/saveLoadV1$ cd ../
(py36) craig@craig-GL63-8RC:~/Documents/Repos/my_netpyne/examples$ cd ../
(py36) craig@craig-GL63-8RC:~/Documents/Repos/my_netpyne$ git merge
fatal: No remote for the current branch.
(py36) craig@craig-GL63-8RC:~/Documents/Repos/my_netpyne$ git merge development
Already up to date.
(py36) craig@craig-GL63-8RC:~/Documents/Repos/my_netpyne$ git merge master
merge: master - not something we can merge

Did you mean this?
	9.4
(py36) craig@craig-GL63-8RC:~/Documents/Repos/my_netpyne$ git push https://github.com/Neurosim-lab/netpyne.git development
Username for 'https://github.com': kelley92
Password for 'https://kelley92@github.com': 
remote: Permission to Neurosim-lab/netpyne.git denied to kelley92.
fatal: unable to access 'https://github.com/Neurosim-lab/netpyne.git/': The requested URL returned error: 403
(py36) craig@craig-GL63-8RC:~/Documents/Repos/my_netpyne$ 
* [2020-2-17 Mon]
** made pull request for examples/saveLoadV1 changes in netpyne
*** needed permissions to push branch
** impledmented Sabina's changes to glymphatic review on overleaf
* [2020-2-18 Tue] 
** issues with inputAndTransfer... scripts
*** running M1 basal - el, M1 apical - au, hay basal - ag, hay apical - pi, eee apical1 - my,  eee apical2 - no, kole - fo
** allen institute cell models - need really high current amplitude to get depolarization, not sure I'm importing correctly
* [2020-2-19 Wed]
** trying to work out why input impedance and channel params so different in all-active allen model compared to perisomatic
*** in all-active, mechanism params match what's in manifest.json as in perisomatic
*** messaged salva re provenance of cell_utils.py
** varying Ih and Im
*** in Hay cell, almost all influence is from Ih
*** very low gbar Im in Hay cell, orders of magnitude smaller than in Kole cell 
** porting chirp resonance stuff to run on GCP 
*** cloned M1_Res repo, compiled mod files
*  [2020-2-20 Thu] - dealing w/ google cloud issues
** issues with GCP
*** importing neuron gui:
---------------------------------------------------------------------------
LookupError                               Traceback (most recent call last)
~/M1_Res/chirpForGCP.py in <module>
      1 # Load in the goods
----> 2 from neuron import h, gui
      3 # h.load_file("stdrun.hoc")
      4 import numpy as np
      5 from scipy.signal import chirp
/usr/local/lib64/python3.6/site-packages/neuron/gui.py in <module>
     88 h.load_file("nrngui.hoc")
     89 
---> 90 h.movie_timer = Timer("moviestep()")
LookupError: 'movie_timer' is not a defined hoc variable name.
*** importing specs from netpyne - easy workaround, but still
---------------------------------------------------------------------------
ImportError                               Traceback (most recent call last)
~/M1_Res/chirpForGCP.py in <module>
      2 from neuron import h
      3 h.load_file("stdrun.hoc")
----> 4 from cfg import cfg
      5 import numpy as np
      6 from scipy.signal import chirp
~/M1_Res/cfg.py in <module>
      7 """
      8 
----> 9 from netpyne import specs
     10 import pickle
     11 
ImportError: cannot import name 'specs'
*** submitting sbatch scripts
[craig_kelley_downstate_edu@g1-login1 M1_Res]$ sbatch gcpTestBatch 
sbatch: error: Batch job submission failed: Invalid account or account/partition combination specified
[craig_kelley_downstate_edu@g1-login1 M1_Res]$  
**** above fixed by salva adding me to some user list
*** above issues more or less resolved, but no *h.run()* . . . muy frustrating
* [2020-2-27 Thu] - loading allen brain cells
** Things are running fine on GCP, will write things up here when finished
** Trying to load all active biophysical models 
*** not explicitly layed out in the docs
*** finally got working:
from allensdk.model.biophys_sim.config import Config                                         
from allensdk.model.biophysical import utils as Utils # this is basically "implied" in the tutorial                                   
description = Config().load('manifest.json')  
utils = Utils.create_utils(description, model_type='Biophysical - all active') # this is insane - help doc says ALL_ACTIVE_TYPE or PERISOMATIC_TYPE for model_type
utils.generate_morphology(morphology_path) # in tutorial, they instead use mophology_path.encode('ascii','ignore')
utils.load_cell_parameters()  
** running allen institute cells on GCP
*** installed allensdk
**** sudo pip3 install allensdk\
*** downloaded all the active cell models 
*** trouble running on GCP
**** can load allensdk from ipython called directly from shell, but it can't import it when called w/ sbatch 
* [2020-2-28 Fri]
** need google password reset for craig.kelley@downstate.edu
** salva's data only has somatic Vm, I want dendrites
* [2020-2-29 Sat]
** resolved allensdk issue on GCP
*** needed to install allensdk and a few dependent packages in /home/craig_kelley_downstate_edu/allensdk/lib/python3.6/site-packages/
** ran one of the allen institute cells, seems to be all good
* [2020-3-7 Sat] - abstract draft
**
Pyramidal neurons in neocortex have complex input-output relationships that depend on their morhpologies, active and
passive channel distributions, and the nature of their inputs, and which cannot be replicated by their simple 
integrate-and-fire analogs. Measures of the complex impedance response across neurons' dendritic arbors, such as 
resonance and the phase response, can provide intraneuronal functional maps reflecting their intrinsic dynamics and excitability. 
Experimental studies of dendritic impedance show that pyramidal neurons in hippocampal CA1 and neocrotex exhibit distance-dependent
relationships for the resonance and the phase responses with respect to the soma. We present a detailed study of
the complex impedance profiles of over a dozen biophysically detailed models of neocortical layer 5 pyramidal neurons from 
across neocortex.  While none of these models were designed to fit the impedance response directly, only two closely 
recapitulate the distance-dependent relationships of the complex impedance response. The  impedance response is also
dynamically tunable via the activity-dependent expression of voltage-gated ion channels in the dendrites, like HCN channels
and M- and A-type K+ channels. We investigated the roles of different voltage-gated ion channels in tuning the impedance response,
showing that changes in HCN and M-type K+ channel conductances, both locally and across the dendritic arbor, can modulate the
impedance response, producing a wide range of profiles.  We also clearly demonstrate the impedance profile's dependence on cell
morphology.  Although a number of cell models exhibit impedance profiles that diverge from the experimental data, some have 
biologically plausible impedance profiles which may reflect regional variation or cells with different histories and therefore
differently tuned impedance responses. In light of the dirth of experimental data on resonance in neocortical pyrmaidal neurons 
from different cortical regions, we hypothesize that neocortical pyramidal neurons have more diverse impedance profiles 
than previously assumed.
* [2020-3-10 Tue] - Introduction outline
** Neocortical pyramidal neurons and Ih 
* [2020-3-11 Wed] - working on manuscript
** see [[../L5PYR_Resonance/paper_notes.org][notes for manuscript]]
* [2020-3-12 Thu] - playing around w/ some impedance stuff
** reran PT cell from M1 with slope=100, made it worse
** running the hay cell w/ max Freq set to 100 Hz to look at bimodal leading phase response, might want to include fig in paper
